{"version":3,"sources":["webpack:///./dist/zingtouch.min.js","webpack:///webpack/bootstrap 213b465cde89201be945","webpack:///./src/core/main.js","webpack:///./src/ZingTouch.js","webpack:///./src/core/classes/Region.js","webpack:///./src/core/classes/Binder.js","webpack:///./src/gestures/Gesture.js","webpack:///./src/core/util.js","webpack:///./src/core/arbiter.js","webpack:///./src/core/dispatcher.js","webpack:///./src/core/interpreter.js","webpack:///./src/core/classes/State.js","webpack:///./src/gestures/Pan.js","webpack:///./src/gestures/Pinch.js","webpack:///./src/gestures/Rotate.js","webpack:///./src/gestures/Swipe.js","webpack:///./src/gestures/Tap.js","webpack:///./src/core/classes/Binding.js","webpack:///./src/core/classes/Input.js","webpack:///./src/core/classes/ZingEvent.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_ZingTouch","_ZingTouch2","window","ZingTouch","Object","defineProperty","value","_Region2","_Region3","_Gesture","_Gesture2","_Pan","_Pan2","_Pinch","_Pinch2","_Rotate","_Rotate2","_Swipe","_Swipe2","_Tap","_Tap2","_regions","Gesture","Pan","Pinch","Rotate","Swipe","Tap","Region","element","capture","preventDefault","length","region","push","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_Binder","_Binder2","_arbiter","_arbiter2","_State","_State2","_this","this","state","State","eventNames","PointerEvent","TouchEvent","forEach","name","addEventListener","e","gesture","handler","bindOnce","tagName","addBinding","Binder","bind","_this2","bindings","retrieveBindingsByElement","unbound","binding","registeredGestures","registeredGesture","removeEventListener","getId","Error","setType","registerGesture","getType","keys","_util","_util2","type","object","inputs","every","input","util","isInside","initial","x","y","CIRCLE_DEGREES","HALF_CIRCLE_DEGREES","normalizeEvent","freeze","mousedown","touchstart","pointerdown","mousemove","touchmove","pointermove","mouseup","touchend","pointerup","isWithin","currentX","currentY","previousX","previousY","tolerance","Math","abs","distanceBetweenTwoPoints","x0","x1","y0","y1","dist","sqrt","round","getMidpoint","getAngle","originX","originY","projectionX","projectionY","angle","atan2","PI","getAngularDistance","start","end","sign","getVelocity","startX","startY","startTime","endX","endY","endTime","distance","getRightMostInput","rightMost","Number","MIN_VALUE","isInteger","rect","getBoundingClientRect","left","width","top","height","getPropagationPath","event","path","node","document","parentNode","getPathIndex","index","setMSPreventDefault","style","removeMSPreventDefault","returnValue","arbiter","eventType","buttons","resetInputs","updateInputs","retrieveBindingsByInitialPos","toBeDispatched","gestures","_interpreter2","_dispatcher2","data","events","endCount","getCurrentEventType","_dispatcher","_interpreter","dispatcher","newEvent","CustomEvent","detail","bubbles","cancelable","emitEvent","dispatchEvent","unbind","interpreter","evType","map","current","candidates","reduce","accumulator","findInputById","identifier","find","_typeof","Symbol","iterator","constructor","_Binding","_Binding2","_Input","_Input2","DEFAULT_MOUSE_ID","regionId","numGestures","boundGesture","indexOf","assignGestureId","Binding","filter","b","some","regionElement","update","Input","touches","pointerType","Array","from","changedTouches","touch","pointerId","endType","setId","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","_Gesture3","DEFAULT_INPUTS","DEFAULT_MIN_THRESHOLD","options","getPrototypeOf","numInputs","threshold","progress","getGestureProgress","active","lastEmitted","packData","distanceFromOrigin","directionFromOrigin","currentDirection","change","_this3","output","distanceFromLastEmit","reachedThreshold","_this4","isValid","lastEmittedDistance","numActiveInputs","currentDistance","centerPoint","center","arguments","undefined","currentPivot","initialPivot","bRect","currentAngle","initialAngle","previousAngle","distanceFromLast","DEFAULT_MAX_REST_TIME","DEFAULT_ESCAPE_VELOCITY","DEFAULT_TIME_DISTORTION","DEFAULT_MAX_PROGRESS_STACK","maxRestTime","escapeVelocity","timeDistortion","maxProgressStack","moves","time","Date","getTime","shift","currentMove","pop","lastMove","velocity","duration","DEFAULT_MIN_DELAY_MS","DEFAULT_MAX_DELAY_MS","DEFAULT_MOVE_PX_TOLERANCE","minDelay","maxDelay","previous","_ret","resetProgress","v","MAX_VALUE","interval","_ZingEvent","_ZingEvent2","currentEvent","ZingEvent","touchIdentifier","INITIAL_COORDINATE","originalEvent","eventObj","t","clientX","clientY","pageX","pageY","screenX","screenY"],"mappings":"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","file":"/home/hciplant/nserc2018/zingtouch/dist/zingtouch.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _ZingTouch = __webpack_require__(1);\n\t\n\tvar _ZingTouch2 = _interopRequireDefault(_ZingTouch);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\twindow.ZingTouch = _ZingTouch2.default; /**\n\t                                         * @file main.js\n\t                                         * Main file to setup event listeners on the document,\n\t                                         * and to expose the ZingTouch object\n\t                                         */\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Region2 = __webpack_require__(2);\n\t\n\tvar _Region3 = _interopRequireDefault(_Region2);\n\t\n\tvar _Gesture = __webpack_require__(4);\n\t\n\tvar _Gesture2 = _interopRequireDefault(_Gesture);\n\t\n\tvar _Pan = __webpack_require__(10);\n\t\n\tvar _Pan2 = _interopRequireDefault(_Pan);\n\t\n\tvar _Pinch = __webpack_require__(11);\n\t\n\tvar _Pinch2 = _interopRequireDefault(_Pinch);\n\t\n\tvar _Rotate = __webpack_require__(12);\n\t\n\tvar _Rotate2 = _interopRequireDefault(_Rotate);\n\t\n\tvar _Swipe = __webpack_require__(13);\n\t\n\tvar _Swipe2 = _interopRequireDefault(_Swipe);\n\t\n\tvar _Tap = __webpack_require__(14);\n\t\n\tvar _Tap2 = _interopRequireDefault(_Tap);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * The global API interface for ZingTouch. Contains a constructor for the\n\t * Region Object, and constructors for each predefined Gesture.\n\t * @type {Object}\n\t * @namespace ZingTouch\n\t */\n\tvar ZingTouch = {\n\t  _regions: [],\n\t\n\t  // Constructors\n\t  Gesture: _Gesture2.default,\n\t  Pan: _Pan2.default,\n\t  Pinch: _Pinch2.default,\n\t  Rotate: _Rotate2.default,\n\t  Swipe: _Swipe2.default,\n\t  Tap: _Tap2.default,\n\t  Region: function Region(element, capture, preventDefault) {\n\t    var id = ZingTouch._regions.length;\n\t    var region = new _Region3.default(element, capture, preventDefault, id);\n\t    ZingTouch._regions.push(region);\n\t    return region;\n\t  }\n\t}; /**\n\t    * @file ZingTouch.js\n\t    * Main object containing API methods and Gesture constructors\n\t    */\n\t\n\texports.default = ZingTouch;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file Region.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\tvar _Binder = __webpack_require__(3);\n\t\n\tvar _Binder2 = _interopRequireDefault(_Binder);\n\t\n\tvar _Gesture = __webpack_require__(4);\n\t\n\tvar _Gesture2 = _interopRequireDefault(_Gesture);\n\t\n\tvar _arbiter = __webpack_require__(6);\n\t\n\tvar _arbiter2 = _interopRequireDefault(_arbiter);\n\t\n\tvar _State = __webpack_require__(9);\n\t\n\tvar _State2 = _interopRequireDefault(_State);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Allows the user to specify a region to capture all events to feed ZingTouch\n\t * into. This can be as narrow as the element itself, or as big as the document\n\t * itself. The more specific an area, the better performant the overall\n\t * application will perform. Contains API methods to bind/unbind specific\n\t * elements to corresponding gestures. Also contains the ability to\n\t * register/unregister new gestures.\n\t * @class Region\n\t */\n\tvar Region = function () {\n\t\n\t  /**\n\t   * Constructor function for the Region class.\n\t   * @param {Element} element - The element to capture all\n\t   *  window events in that region to feed into ZingTouch.\n\t   * @param {boolean} [capture=false] - Whether the region listens for\n\t   *  captures or bubbles.\n\t   * @param {boolean} [preventDefault=true] - Whether the default browser\n\t   *  functionality should be disabled;\n\t   * @param {Number} id - The id of the region, assigned by the ZingTouch object\n\t   */\n\t  function Region(element, capture, preventDefault, id) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Region);\n\t\n\t    /**\n\t     * The identifier for the Region. This is assigned by the ZingTouch object\n\t     * and is used to hash gesture id for uniqueness.\n\t     * @type {Number}\n\t     */\n\t    this.id = id;\n\t\n\t    /**\n\t     * The element being bound to.\n\t     * @type {Element}\n\t     */\n\t    this.element = element;\n\t\n\t    /**\n\t     * Whether the region listens for captures or bubbles.\n\t     * @type {boolean}\n\t     */\n\t    this.capture = typeof capture !== 'undefined' ? capture : false;\n\t\n\t    /**\n\t     * Boolean to disable browser functionality such as scrolling and zooming\n\t     * over the region\n\t     * @type {boolean}\n\t     */\n\t    this.preventDefault = typeof preventDefault !== 'undefined' ? preventDefault : true;\n\t\n\t    /**\n\t     * The internal state object for a Region.\n\t     * Keeps track of registered gestures, inputs, and events.\n\t     * @type {State}\n\t     */\n\t    this.state = new _State2.default(id);\n\t\n\t    var eventNames = [];\n\t    if (window.PointerEvent && !window.TouchEvent) {\n\t      eventNames = ['pointerdown', 'pointermove', 'pointerup'];\n\t    } else {\n\t      eventNames = ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend'];\n\t    }\n\t\n\t    // Bind detected browser events to the region element.\n\t    eventNames.forEach(function (name) {\n\t      element.addEventListener(name, function (e) {\n\t        (0, _arbiter2.default)(e, _this);\n\t      }, _this.capture);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Bind an element to a registered/unregistered gesture with\n\t   * multiple function signatures.\n\t   * @example\n\t   * bind(element) - chainable\n\t   * @example\n\t   * bind(element, gesture, handler, [capture])\n\t   * @param {Element} element - The element object.\n\t   * @param {String|Object} [gesture] - Gesture key, or a Gesture object.\n\t   * @param {Function} [handler] - The function to execute when an event is\n\t   *  emitted.\n\t   * @param {Boolean} [capture] - capture/bubble\n\t   * @param {Boolean} [bindOnce = false] - Option to bind once and\n\t   *  only emit the event once.\n\t   * @return {Object} - a chainable object that has the same function as bind.\n\t   */\n\t\n\t\n\t  _createClass(Region, [{\n\t    key: 'bind',\n\t    value: function bind(element, gesture, handler, capture, bindOnce) {\n\t      if (!element || element && !element.tagName) {\n\t        throw 'Bind must contain an element';\n\t      }\n\t\n\t      bindOnce = typeof bindOnce !== 'undefined' ? bindOnce : false;\n\t      if (!gesture) {\n\t        return new _Binder2.default(element, bindOnce, this.state);\n\t      } else {\n\t        this.state.addBinding(element, gesture, handler, capture, bindOnce);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Bind an element and sets up actions to remove the binding once\n\t     * it has been emitted for the first time.\n\t     * 1. bind(element) - chainable\n\t     * 2. bind(element, gesture, handler, [capture])\n\t     * @param {Element} element - The element object.\n\t     * @param {String|Object} gesture - Gesture key, or a Gesture object.\n\t     * @param {Function} handler - The function to execute when an\n\t     *  event is emitted.\n\t     * @param {Boolean} capture - capture/bubble\n\t     * @return {Object} - a chainable object that has the same function as bind.\n\t     */\n\t\n\t  }, {\n\t    key: 'bindOnce',\n\t    value: function bindOnce(element, gesture, handler, capture) {\n\t      this.bind(element, gesture, handler, capture, true);\n\t    }\n\t\n\t    /**\n\t     * Unbinds an element from either the specified gesture\n\t     *  or all if no element is specified.\n\t     * @param {Element} element -The element to remove.\n\t     * @param {String | Object} [gesture] - A String representing the gesture,\n\t     *   or the actual object being used.\n\t     * @return {Array} - An array of Bindings that were unbound to the element;\n\t     */\n\t\n\t  }, {\n\t    key: 'unbind',\n\t    value: function unbind(element, gesture) {\n\t      var _this2 = this;\n\t\n\t      var bindings = this.state.retrieveBindingsByElement(element);\n\t      var unbound = [];\n\t\n\t      bindings.forEach(function (binding) {\n\t        if (gesture) {\n\t          if (typeof gesture === 'string' && _this2.state.registeredGestures[gesture]) {\n\t            var registeredGesture = _this2.state.registeredGestures[gesture];\n\t            if (registeredGesture.id === binding.gesture.id) {\n\t              element.removeEventListener(binding.gesture.getId(), binding.handler, binding.capture);\n\t              unbound.push(binding);\n\t            }\n\t          }\n\t        } else {\n\t          element.removeEventListener(binding.gesture.getId(), binding.handler, binding.capture);\n\t          unbound.push(binding);\n\t        }\n\t      });\n\t\n\t      return unbound;\n\t    }\n\t\n\t    /* unbind*/\n\t\n\t    /**\n\t     * Registers a new gesture with an assigned key\n\t     * @param {String} key - The key used to register an element to that gesture\n\t     * @param {Gesture} gesture - A gesture object\n\t     */\n\t\n\t  }, {\n\t    key: 'register',\n\t    value: function register(key, gesture) {\n\t      if (typeof key !== 'string') {\n\t        throw new Error('Parameter key is an invalid string');\n\t      }\n\t\n\t      if (!gesture instanceof _Gesture2.default) {\n\t        throw new Error('Parameter gesture is an invalid Gesture object');\n\t      }\n\t\n\t      gesture.setType(key);\n\t      this.state.registerGesture(gesture, key);\n\t    }\n\t\n\t    /* register*/\n\t\n\t    /**\n\t     * Un-registers a gesture from the Region's state such that\n\t     * it is no longer emittable.\n\t     * Unbinds all events that were registered with the type.\n\t     * @param {String|Object} key - Gesture key that was used to\n\t     *  register the object\n\t     * @return {Object} - The Gesture object that was unregistered\n\t     *  or null if it could not be found.\n\t     */\n\t\n\t  }, {\n\t    key: 'unregister',\n\t    value: function unregister(key) {\n\t      this.state.bindings.forEach(function (binding) {\n\t        if (binding.gesture.getType() === key) {\n\t          binding.element.removeEventListener(binding.gesture.getId(), binding.handler, binding.capture);\n\t        }\n\t      });\n\t\n\t      var registeredGesture = this.state.registeredGestures[key];\n\t      delete this.state.registeredGestures[key];\n\t      return registeredGesture;\n\t    }\n\t  }]);\n\t\n\t  return Region;\n\t}();\n\t\n\texports.default = Region;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @file Binder.js\n\t */\n\t\n\t/**\n\t * A chainable object that contains a single element to be bound upon.\n\t * Called from ZingTouch.bind(), and is used to chain over gesture callbacks.\n\t * @class\n\t */\n\tvar Binder =\n\t/**\n\t * Constructor function for the Binder class.\n\t * @param {Element} element - The element to bind gestures to.\n\t * @param {Boolean} bindOnce - Option to bind once and only emit\n\t * the event once.\n\t * @param {Object} state - The state of the Region that is being bound to.\n\t * @return {Object} - Returns 'this' to be chained over and over again.\n\t */\n\tfunction Binder(element, bindOnce, state) {\n\t  var _this = this;\n\t\n\t  _classCallCheck(this, Binder);\n\t\n\t  /**\n\t   * The element to bind gestures to.\n\t   * @type {Element}\n\t   */\n\t  this.element = element;\n\t\n\t  Object.keys(state.registeredGestures).forEach(function (key) {\n\t    _this[key] = function (handler, capture) {\n\t      state.addBinding(_this.element, key, handler, capture, bindOnce);\n\t      return _this;\n\t    };\n\t  });\n\t};\n\t\n\texports.default = Binder;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file Gesture.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Contains the Gesture class\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * The Gesture class that all gestures inherit from.\n\t */\n\tvar Gesture = function () {\n\t  /**\n\t   * Constructor function for the Gesture class.\n\t   * @class Gesture\n\t   */\n\t  function Gesture() {\n\t    _classCallCheck(this, Gesture);\n\t\n\t    /**\n\t     * The generic string type of gesture ('expand'|'pan'|'pinch'|\n\t     *  'rotate'|'swipe'|'tap').\n\t     * @type {String}\n\t     */\n\t    this.type = null;\n\t\n\t    /**\n\t     * The unique identifier for each gesture determined at bind time by the\n\t     * state object. This allows for distinctions across instance variables of\n\t     * Gestures that are created on the fly (e.g. Tap-1, Tap-2, etc).\n\t     * @type {String|null}\n\t     */\n\t    this.id = null;\n\t  }\n\t\n\t  /**\n\t   * Set the type of the gesture to be called during an event\n\t   * @param {String} type - The unique identifier of the gesture being created.\n\t   */\n\t\n\t\n\t  _createClass(Gesture, [{\n\t    key: 'setType',\n\t    value: function setType(type) {\n\t      this.type = type;\n\t    }\n\t\n\t    /**\n\t     * getType() - Returns the generic type of the gesture\n\t     * @return {String} - The type of gesture\n\t     */\n\t\n\t  }, {\n\t    key: 'getType',\n\t    value: function getType() {\n\t      return this.type;\n\t    }\n\t\n\t    /**\n\t     * Set the id of the gesture to be called during an event\n\t     * @param {String} id - The unique identifier of the gesture being created.\n\t     */\n\t\n\t  }, {\n\t    key: 'setId',\n\t    value: function setId(id) {\n\t      this.id = id;\n\t    }\n\t\n\t    /**\n\t     * Return the id of the event. If the id does not exist, return the type.\n\t     * @return {String}\n\t     */\n\t\n\t  }, {\n\t    key: 'getId',\n\t    value: function getId() {\n\t      return this.id !== null ? this.id : this.type;\n\t    }\n\t\n\t    /**\n\t     * Updates internal properties with new ones, only if the properties exist.\n\t     * @param {Object} object\n\t     */\n\t\n\t  }, {\n\t    key: 'update',\n\t    value: function update(object) {\n\t      var _this = this;\n\t\n\t      Object.keys(object).forEach(function (key) {\n\t        _this[key] = object[key];\n\t      });\n\t    }\n\t\n\t    /**\n\t     * start() - Event hook for the start of a gesture\n\t     * @param {Array} inputs - The array of Inputs on the screen\n\t    * @param {Object} state - The state object of the current region.\n\t    * @param {Element} element - The element associated to the binding.\n\t     * @return {null|Object}  - Default of null\n\t     */\n\t\n\t  }, {\n\t    key: 'start',\n\t    value: function start(inputs, state, element) {\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * move() - Event hook for the move of a gesture\n\t     * @param {Array} inputs - The array of Inputs on the screen\n\t     * @param {Object} state - The state object of the current region.\n\t     * @param {Element} element - The element associated to the binding.\n\t     * @return {null|Object} - Default of null\n\t     */\n\t\n\t  }, {\n\t    key: 'move',\n\t    value: function move(inputs, state, element) {\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * end() - Event hook for the move of a gesture\n\t     * @param {Array} inputs - The array of Inputs on the screen\n\t     * @return {null|Object}  - Default of null\n\t     */\n\t\n\t  }, {\n\t    key: 'end',\n\t    value: function end(inputs) {\n\t      return null;\n\t    }\n\t\n\t    /**\n\t    * isValid() - Pre-checks to ensure the invariants of a gesture are satisfied.\n\t    * @param {Array} inputs - The array of Inputs on the screen\n\t    * @param {Object} state - The state object of the current region.\n\t    * @param {Element} element - The element associated to the binding.\n\t    * @return {boolean} - If the gesture is valid\n\t    */\n\t\n\t  }, {\n\t    key: 'isValid',\n\t    value: function isValid(inputs, state, element) {\n\t      return inputs.every(function (input) {\n\t        return _util2.default.isInside(input.initial.x, input.initial.y, element);\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Gesture;\n\t}();\n\t\n\texports.default = Gesture;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * @file util.js\n\t * Various accessor and mutator functions to handle state and validation.\n\t */\n\t\n\tvar CIRCLE_DEGREES = 360;\n\tvar HALF_CIRCLE_DEGREES = 180;\n\t\n\t/**\n\t *  Contains generic helper functions\n\t * @type {Object}\n\t * @namespace util\n\t */\n\tvar util = {\n\t\n\t  /**\n\t   * Normalizes window events to be either of type start, move, or end.\n\t   * @param {String} type - The event type emitted by the browser\n\t   * @return {null|String} - The normalized event, or null if it is an\n\t   * event not predetermined.\n\t   */\n\t  normalizeEvent: Object.freeze({\n\t    mousedown: 'start',\n\t    touchstart: 'start',\n\t    pointerdown: 'start',\n\t\n\t    mousemove: 'move',\n\t    touchmove: 'move',\n\t    pointermove: 'move',\n\t\n\t    mouseup: 'end',\n\t    touchend: 'end',\n\t    pointerup: 'end'\n\t  }),\n\t  /* normalizeEvent*/\n\t\n\t  /**\n\t   * Determines if the current and previous coordinates are within or\n\t   * up to a certain tolerance.\n\t   * @param {Number} currentX - Current event's x coordinate\n\t   * @param {Number} currentY - Current event's y coordinate\n\t   * @param {Number} previousX - Previous event's x coordinate\n\t   * @param {Number} previousY - Previous event's y coordinate\n\t   * @param {Number} tolerance - The tolerance in pixel value.\n\t   * @return {boolean} - true if the current coordinates are\n\t   * within the tolerance, false otherwise\n\t   */\n\t  isWithin: function isWithin(currentX, currentY, previousX, previousY, tolerance) {\n\t    return Math.abs(currentY - previousY) <= tolerance && Math.abs(currentX - previousX) <= tolerance;\n\t  },\n\t\n\t  /* isWithin*/\n\t\n\t  /**\n\t   * Calculates the distance between two points.\n\t   * @param {Number} x0\n\t   * @param {Number} x1\n\t   * @param {Number} y0\n\t   * @param {Number} y1\n\t   * @return {number} The numerical value between two points\n\t   */\n\t  distanceBetweenTwoPoints: function distanceBetweenTwoPoints(x0, x1, y0, y1) {\n\t    var dist = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n\t    return Math.round(dist * 100) / 100;\n\t  },\n\t\n\t\n\t  /**\n\t   * Calculates the midpoint coordinates between two points.\n\t   * @param {Number} x0\n\t   * @param {Number} x1\n\t   * @param {Number} y0\n\t   * @param {Number} y1\n\t   * @return {Object} The coordinates of the midpoint.\n\t   */\n\t  getMidpoint: function getMidpoint(x0, x1, y0, y1) {\n\t    return {\n\t      x: (x0 + x1) / 2,\n\t      y: (y0 + y1) / 2\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Calculates the angle between the projection and an origin point.\n\t   *   |                (projectionX,projectionY)\n\t   *   |             /\n\t   *   |          /\n\t   *   |       /\n\t   *   |    / \n\t   *   | /__________\n\t   *    (originX, originY)\n\t   * @param {number} originX\n\t   * @param {number} originY\n\t   * @param {number} projectionX\n\t   * @param {number} projectionY\n\t   * @return {number} - Degree along the unit circle where the project lies\n\t   */\n\t  getAngle: function getAngle(originX, originY, projectionX, projectionY) {\n\t    var angle = Math.atan2(projectionY - originY, projectionX - originX) * (HALF_CIRCLE_DEGREES / Math.PI);\n\t    return CIRCLE_DEGREES - (angle < 0 ? CIRCLE_DEGREES + angle : angle);\n\t  },\n\t\n\t  /**\n\t   * Calculates the angular distance in degrees between two angles\n\t   *  along the unit circle\n\t   * @param {number} start - The starting point in degrees\n\t   * @param {number} end - The ending point in degrees\n\t   * @return {number} The number of degrees between the\n\t   * starting point and ending point. Negative degrees denote a clockwise\n\t   * direction, and positive a counter-clockwise direction.\n\t   */\n\t  getAngularDistance: function getAngularDistance(start, end) {\n\t    var angle = (end - start) % CIRCLE_DEGREES;\n\t    var sign = angle < 0 ? 1 : -1;\n\t    angle = Math.abs(angle);\n\t    return angle > HALF_CIRCLE_DEGREES ? sign * (CIRCLE_DEGREES - angle) : sign * angle;\n\t  },\n\t\n\t\n\t  /**\n\t   * Calculates the velocity of pixel/milliseconds between two points\n\t   * @param {Number} startX\n\t   * @param {Number} startY\n\t   * @param {Number} startTime\n\t   * @param {Number} endX\n\t   * @param {Number} endY\n\t   * @param {Number} endTime\n\t   * @return {Number} velocity of px/time\n\t   */\n\t  getVelocity: function getVelocity(startX, startY, startTime, endX, endY, endTime) {\n\t    var distance = this.distanceBetweenTwoPoints(startX, endX, startY, endY);\n\t    return distance / (endTime - startTime);\n\t  },\n\t\n\t\n\t  /**\n\t   * Returns the farthest right input\n\t   * @param {Array} inputs\n\t   * @return {Object}\n\t   */\n\t  getRightMostInput: function getRightMostInput(inputs) {\n\t    var rightMost = null;\n\t    var distance = Number.MIN_VALUE;\n\t    inputs.forEach(function (input) {\n\t      if (input.initial.x > distance) {\n\t        rightMost = input;\n\t      }\n\t    });\n\t    return rightMost;\n\t  },\n\t\n\t\n\t  /**\n\t   * Determines is the value is an integer and not a floating point\n\t   * @param {Mixed} value\n\t   * @return {boolean}\n\t   */\n\t  isInteger: function isInteger(value) {\n\t    return typeof value === 'number' && value % 1 === 0;\n\t  },\n\t\n\t\n\t  /**\n\t   * Determines if the x,y position of the input is within then target.\n\t   * @param {Number} x -clientX\n\t   * @param {Number} y -clientY\n\t   * @param {Element} target\n\t   * @return {Boolean}\n\t   */\n\t  isInside: function isInside(x, y, target) {\n\t    var rect = target.getBoundingClientRect();\n\t    return x > rect.left && x < rect.left + rect.width && y > rect.top && y < rect.top + rect.height;\n\t  },\n\t\n\t  /**\n\t   * Polyfill for event.propagationPath\n\t   * @param {Event} event\n\t   * @return {Array}\n\t   */\n\t  getPropagationPath: function getPropagationPath(event) {\n\t    if (event.path) {\n\t      return event.path;\n\t    } else {\n\t      var path = [];\n\t      var node = event.target;\n\t      while (node != document) {\n\t        path.push(node);\n\t        node = node.parentNode;\n\t      }\n\t\n\t      return path;\n\t    }\n\t  },\n\t\n\t\n\t  /**\n\t   * Retrieve the index inside the path array\n\t   * @param {Array} path\n\t   * @param {Element} element\n\t   * @return {Element}\n\t   */\n\t  getPathIndex: function getPathIndex(path, element) {\n\t    var index = path.length;\n\t\n\t    path.forEach(function (obj, i) {\n\t      if (obj === element) {\n\t        index = i;\n\t      }\n\t    });\n\t\n\t    return index;\n\t  },\n\t  setMSPreventDefault: function setMSPreventDefault(element) {\n\t    element.style['-ms-content-zooming'] = 'none';\n\t    element.style['touch-action'] = 'none';\n\t  },\n\t  removeMSPreventDefault: function removeMSPreventDefault(element) {\n\t    element.style['-ms-content-zooming'] = '';\n\t    element.style['touch-action'] = '';\n\t  },\n\t  preventDefault: function preventDefault(event) {\n\t    if (event.preventDefault) {\n\t      event.preventDefault();\n\t    } else {\n\t      event.returnValue = false;\n\t    }\n\t  }\n\t};\n\t\n\texports.default = util;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _dispatcher = __webpack_require__(7);\n\t\n\tvar _dispatcher2 = _interopRequireDefault(_dispatcher);\n\t\n\tvar _interpreter = __webpack_require__(8);\n\t\n\tvar _interpreter2 = _interopRequireDefault(_interpreter);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Function that handles event flow, negotiating with the interpreter,\n\t * and dispatcher.\n\t * 1. Receiving all touch events in the window.\n\t * 2. Determining which gestures are linked to the target element.\n\t * 3. Negotiating with the Interpreter what event should occur.\n\t * 4. Sending events to the dispatcher to emit events to the target.\n\t * @param {Event} event - The event emitted from the window object.\n\t * @param {Object} region - The region object of the current listener.\n\t */\n\tfunction arbiter(event, region) {\n\t  var state = region.state;\n\t  var eventType = _util2.default.normalizeEvent[event.type];\n\t\n\t  /*\n\t   Return if a gesture is not in progress and won't be. Also catches the case\n\t   where a previous event is in a partial state (2 finger pan, waits for both\n\t   inputs to reach touchend)\n\t   */\n\t  if (state.inputs.length === 0 && eventType !== 'start') {\n\t    return;\n\t  }\n\t\n\t  /*\n\t   Check for 'stale' or events that lost focus\n\t   (e.g. a pan goes off screen/off region.)\n\t   Does not affect mobile devices.\n\t   */\n\t  if (typeof event.buttons !== 'undefined' && eventType !== 'end' && event.buttons === 0) {\n\t    state.resetInputs();\n\t    return;\n\t  }\n\t\n\t  // Update the state with the new events. If the event is stopped, return;\n\t  if (!state.updateInputs(event, region.element)) {\n\t    return;\n\t  }\n\t\n\t  // Retrieve the initial target from any one of the inputs\n\t  var bindings = state.retrieveBindingsByInitialPos();\n\t  if (bindings.length > 0) {\n\t    if (region.preventDefault) {\n\t      _util2.default.setMSPreventDefault(region.element);\n\t      _util2.default.preventDefault(event);\n\t    } else {\n\t      _util2.default.removeMSPreventDefault(region.element);\n\t    }\n\t\n\t    var toBeDispatched = {};\n\t    var gestures = (0, _interpreter2.default)(bindings, event, state);\n\t\n\t    /* Determine the deepest path index to emit the event\n\t     from, to avoid duplicate events being fired. */\n\t\n\t    var path = _util2.default.getPropagationPath(event);\n\t    gestures.forEach(function (gesture) {\n\t      var id = gesture.binding.gesture.getId();\n\t      if (toBeDispatched[id]) {\n\t        if (_util2.default.getPathIndex(path, gesture.binding.element) < _util2.default.getPathIndex(path, toBeDispatched[id].binding.element)) {\n\t          toBeDispatched[id] = gesture;\n\t        }\n\t      } else {\n\t        toBeDispatched[id] = gesture;\n\t      }\n\t    });\n\t\n\t    Object.keys(toBeDispatched).forEach(function (index) {\n\t      var gesture = toBeDispatched[index];\n\t      (0, _dispatcher2.default)(gesture.binding, gesture.data, gesture.events);\n\t    });\n\t  }\n\t\n\t  var endCount = 0;\n\t  state.inputs.forEach(function (input) {\n\t    if (input.getCurrentEventType() === 'end') {\n\t      endCount++;\n\t    }\n\t  });\n\t\n\t  if (endCount === state.inputs.length) {\n\t    state.resetInputs();\n\t  }\n\t} /**\n\t   * @file arbiter.js\n\t   * Contains logic for the dispatcher\n\t   */\n\t\n\texports.default = arbiter;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * @file dispatcher.js\n\t * Contains logic for the dispatcher\n\t */\n\t\n\t/**\n\t * Emits data at the target element if available, and bubbles up from\n\t * the target to the parent until the document has been reached.\n\t * Called from the arbiter.\n\t * @param {Binding} binding - An object of type Binding\n\t * @param {Object} data - The metadata computed by the gesture being emitted.\n\t * @param {Array} events - An array of ZingEvents\n\t *  corresponding to the inputs on the screen.\n\t */\n\tfunction dispatcher(binding, data, events) {\n\t  data.events = events;\n\t\n\t  var newEvent = new CustomEvent(binding.gesture.getId(), {\n\t    detail: data,\n\t    bubbles: true,\n\t    cancelable: true\n\t  });\n\t  emitEvent(binding.element, newEvent, binding);\n\t}\n\t\n\t/**\n\t * Emits the new event. Unbinds the event if the event was registered\n\t * at bindOnce.\n\t * @param {Element} target - Element object to emit the event to.\n\t * @param {Event} event - The CustomEvent to emit.\n\t * @param {Binding} binding - An object of type Binding\n\t */\n\tfunction emitEvent(target, event, binding) {\n\t  target.dispatchEvent(event);\n\t  if (binding.bindOnce) {\n\t    ZingTouch.unbind(binding.element, binding.gesture.getType());\n\t  }\n\t}\n\t\n\texports.default = dispatcher;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Receives an event and an array of Bindings (element -> gesture handler)\n\t * to determine what event will be emitted. Called from the arbiter.\n\t * @param {Array} bindings - An array containing Binding objects\n\t * that associate the element to an event handler.\n\t * @param {Object} event - The event emitted from the window.\n\t * @param {Object} state - The state object of the current listener.\n\t * @return {Object | null} - Returns an object containing a binding and\n\t * metadata, or null if a gesture will not be emitted.\n\t */\n\tfunction interpreter(bindings, event, state) {\n\t  var evType = _util2.default.normalizeEvent[event.type];\n\t  var events = state.inputs.map(function (input) {\n\t    return input.current;\n\t  });\n\t\n\t  var candidates = bindings.reduce(function (accumulator, binding) {\n\t    var data = binding.gesture[evType](state.inputs, state, binding.element);\n\t    if (data) accumulator.push({ binding: binding, data: data, events: events });\n\t    return accumulator;\n\t  }, []);\n\t\n\t  return candidates;\n\t} /**\n\t   * @file interpreter.js\n\t   * Contains logic for the interpreter\n\t   */\n\t\n\texports.default = interpreter;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file State.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\tvar _Gesture = __webpack_require__(4);\n\t\n\tvar _Gesture2 = _interopRequireDefault(_Gesture);\n\t\n\tvar _Pan = __webpack_require__(10);\n\t\n\tvar _Pan2 = _interopRequireDefault(_Pan);\n\t\n\tvar _Pinch = __webpack_require__(11);\n\t\n\tvar _Pinch2 = _interopRequireDefault(_Pinch);\n\t\n\tvar _Rotate = __webpack_require__(12);\n\t\n\tvar _Rotate2 = _interopRequireDefault(_Rotate);\n\t\n\tvar _Swipe = __webpack_require__(13);\n\t\n\tvar _Swipe2 = _interopRequireDefault(_Swipe);\n\t\n\tvar _Tap = __webpack_require__(14);\n\t\n\tvar _Tap2 = _interopRequireDefault(_Tap);\n\t\n\tvar _Binding = __webpack_require__(15);\n\t\n\tvar _Binding2 = _interopRequireDefault(_Binding);\n\t\n\tvar _Input = __webpack_require__(16);\n\t\n\tvar _Input2 = _interopRequireDefault(_Input);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEFAULT_MOUSE_ID = 0;\n\t\n\t/**\n\t * Creates an object related to a Region's state,\n\t * and contains helper methods to update and clean up different states.\n\t */\n\t\n\tvar State = function () {\n\t\n\t  /**\n\t   * Constructor for the State class.\n\t   * @param {String} regionId - The id the region this state is bound to.\n\t   */\n\t  function State(regionId) {\n\t    _classCallCheck(this, State);\n\t\n\t    /**\n\t     * The id for the region this state is bound to.\n\t     * @type {String}\n\t     */\n\t    this.regionId = regionId;\n\t\n\t    /**\n\t     * An array of current and recently inactive\n\t     *  Input objects related to a gesture.\n\t     * @type {Input}\n\t     */\n\t    this.inputs = [];\n\t\n\t    /**\n\t     * An array of Binding objects; The list of relations between elements,\n\t     *   their gestures, and the handlers.\n\t     * @type {Binding}\n\t     */\n\t    this.bindings = [];\n\t\n\t    /**\n\t     * The number of gestures that have been registered with this state\n\t     * @type {Number}\n\t     */\n\t    this.numGestures = 0;\n\t\n\t    /**\n\t     * A key/value map all the registered gestures for the listener.\n\t     *  Note: Can only have one gesture registered to one key.\n\t     * @type {Object}\n\t     */\n\t    this.registeredGestures = {};\n\t\n\t    this.registerGesture(new _Pan2.default(), 'pan');\n\t    this.registerGesture(new _Rotate2.default(), 'rotate');\n\t    this.registerGesture(new _Pinch2.default(), 'pinch');\n\t    this.registerGesture(new _Swipe2.default(), 'swipe');\n\t    this.registerGesture(new _Tap2.default(), 'tap');\n\t  }\n\t\n\t  /**\n\t   * Creates a new binding with the given element and gesture object.\n\t   * If the gesture object provided is unregistered, it's reference\n\t   * will be saved in as a binding to be later referenced.\n\t   * @param  {Element} element - The element the gesture is bound to.\n\t   * @param {String|Object} gesture  - Either a name of a registered gesture,\n\t   *  or an unregistered  Gesture object.\n\t   * @param {Function} handler - The function handler to be called\n\t   *  when the event is emitted. Used to bind/unbind.\n\t   * @param {Boolean} capture - Whether the gesture is to be\n\t   *  detected in the capture of bubble phase. Used to bind/unbind.\n\t   * @param {Boolean} bindOnce - Option to bind once and\n\t   *  only emit the event once.\n\t   */\n\t\n\t\n\t  _createClass(State, [{\n\t    key: 'addBinding',\n\t    value: function addBinding(element, gesture, handler, capture, bindOnce) {\n\t      var boundGesture = void 0;\n\t\n\t      // Error type checking.\n\t      if (element && typeof element.tagName === 'undefined') {\n\t        throw new Error('Parameter element is an invalid object.');\n\t      }\n\t\n\t      if (typeof handler !== 'function') {\n\t        throw new Error('Parameter handler is invalid.');\n\t      }\n\t\n\t      if (typeof gesture === 'string' && Object.keys(this.registeredGestures).indexOf(gesture) === -1) {\n\t        throw new Error('Parameter ' + gesture + ' is not a registered gesture');\n\t      } else if ((typeof gesture === 'undefined' ? 'undefined' : _typeof(gesture)) === 'object' && !(gesture instanceof _Gesture2.default)) {\n\t        throw new Error('Parameter for the gesture is not of a Gesture type');\n\t      }\n\t\n\t      if (typeof gesture === 'string') {\n\t        boundGesture = this.registeredGestures[gesture];\n\t      } else {\n\t        boundGesture = gesture;\n\t        if (boundGesture.id === '') {\n\t          this.assignGestureId(boundGesture);\n\t        }\n\t      }\n\t\n\t      this.bindings.push(new _Binding2.default(element, boundGesture, handler, capture, bindOnce));\n\t      element.addEventListener(boundGesture.getId(), handler, capture);\n\t    }\n\t\n\t    /**\n\t     * Retrieves the Binding by which an element is associated to.\n\t     * @param {Element} element - The element to find bindings to.\n\t     * @return {Array} - An array of Bindings to which that element is bound\n\t     */\n\t\n\t  }, {\n\t    key: 'retrieveBindingsByElement',\n\t    value: function retrieveBindingsByElement(element) {\n\t      return this.bindings.filter(function (b) {\n\t        return b.element === element;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Retrieves all bindings based upon the initial X/Y position of the inputs.\n\t     * e.g. if gesture started on the correct target element,\n\t     *  but diverted away into the correct region, this would still be valid.\n\t     * @return {Array} - An array of Bindings to which that element is bound\n\t     */\n\t\n\t  }, {\n\t    key: 'retrieveBindingsByInitialPos',\n\t    value: function retrieveBindingsByInitialPos() {\n\t      var _this = this;\n\t\n\t      return this.bindings.filter(function (binding) {\n\t        return _this.inputs.some(function (input) {\n\t          return _util2.default.isInside(input.initial.x, input.initial.y, binding.element);\n\t        });\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Updates the inputs with new information based upon a new event being fired.\n\t     * @param {Event} event - The event being captured.\n\t     * @param {Element} regionElement - The element where\n\t     *  this current Region is bound to.\n\t     * @return {boolean} - returns true for a successful update,\n\t     *  false if the event is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: 'updateInputs',\n\t    value: function updateInputs(event, regionElement) {\n\t      var _this2 = this;\n\t\n\t      var eventType = event.touches ? 'TouchEvent' : event.pointerType ? 'PointerEvent' : 'MouseEvent';\n\t      switch (eventType) {\n\t        case 'TouchEvent':\n\t          Array.from(event.changedTouches).forEach(function (touch) {\n\t            update(event, _this2, touch.identifier, regionElement);\n\t          });\n\t          break;\n\t\n\t        case 'PointerEvent':\n\t          update(event, this, event.pointerId, regionElement);\n\t          break;\n\t\n\t        case 'MouseEvent':\n\t        default:\n\t          update(event, this, DEFAULT_MOUSE_ID, regionElement);\n\t          break;\n\t      }\n\t      return true;\n\t\n\t      function update(event, state, identifier, regionElement) {\n\t        var eventType = _util2.default.normalizeEvent[event.type];\n\t        var input = findInputById(state.inputs, identifier);\n\t\n\t        // A starting input was not cleaned up properly and still exists.\n\t        if (eventType === 'start' && input) {\n\t          state.resetInputs();\n\t          return;\n\t        }\n\t\n\t        // An input has moved outside the region.\n\t        if (eventType !== 'start' && input && !_util2.default.isInside(input.current.x, input.current.y, regionElement)) {\n\t          state.resetInputs();\n\t          return;\n\t        }\n\t\n\t        if (eventType !== 'start' && !input) {\n\t          state.resetInputs();\n\t          return;\n\t        }\n\t\n\t        if (eventType === 'start') {\n\t          state.inputs.push(new _Input2.default(event, identifier));\n\t        } else {\n\t          input.update(event, identifier);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Removes all inputs from the state, allowing for a new gesture.\n\t     */\n\t\n\t  }, {\n\t    key: 'resetInputs',\n\t    value: function resetInputs() {\n\t      this.inputs = [];\n\t    }\n\t\n\t    /**\n\t     * Counts the number of active inputs at any given time.\n\t     * @return {Number} - The number of active inputs.\n\t     */\n\t\n\t  }, {\n\t    key: 'numActiveInputs',\n\t    value: function numActiveInputs() {\n\t      var endType = this.inputs.filter(function (input) {\n\t        return input.current.type !== 'end';\n\t      });\n\t      return endType.length;\n\t    }\n\t\n\t    /**\n\t     * Register the gesture to the current region.\n\t     * @param {Object} gesture - The gesture to register\n\t     * @param {String} key - The key to define the new gesture as.\n\t     */\n\t\n\t  }, {\n\t    key: 'registerGesture',\n\t    value: function registerGesture(gesture, key) {\n\t      this.assignGestureId(gesture);\n\t      this.registeredGestures[key] = gesture;\n\t    }\n\t\n\t    /**\n\t     * Tracks the gesture to this state object to become uniquely identifiable.\n\t     * Useful for nested Regions.\n\t     * @param {Gesture} gesture - The gesture to track\n\t     */\n\t\n\t  }, {\n\t    key: 'assignGestureId',\n\t    value: function assignGestureId(gesture) {\n\t      gesture.setId(this.regionId + '-' + this.numGestures++);\n\t    }\n\t  }]);\n\t\n\t  return State;\n\t}();\n\t/**\n\t * Searches through each input, comparing the browser's identifier key\n\t *  for touches, to the stored one in each input\n\t * @param {Array} inputs - The array of inputs in state.\n\t * @param {String} identifier - The identifier the browser has assigned.\n\t * @return {Input} - The input object with the corresponding identifier,\n\t *  null if it did not find any.\n\t */\n\t\n\t\n\tfunction findInputById(inputs, identifier) {\n\t  return inputs.find(function (i) {\n\t    return i.identifier === identifier;\n\t  });\n\t}\n\t\n\texports.default = State;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Gesture2 = __webpack_require__(4);\n\t\n\tvar _Gesture3 = _interopRequireDefault(_Gesture2);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file Pan.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Contains the Pan class\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar DEFAULT_INPUTS = 1;\n\tvar DEFAULT_MIN_THRESHOLD = 1;\n\t\n\t/**\n\t * A Pan is defined as a normal movement in any direction on a screen.\n\t * Pan gestures do not track start events and can interact with pinch and \\\n\t *  expand gestures.\n\t * @class Pan\n\t */\n\t\n\tvar Pan = function (_Gesture) {\n\t  _inherits(Pan, _Gesture);\n\t\n\t  /**\n\t   * Constructor function for the Pan class.\n\t   * @param {Object} [options] - The options object.\n\t   * @param {Number} [options.numInputs=1] - Number of inputs for the\n\t   *  Pan gesture.\n\t   * @param {Number} [options.threshold=1] - The minimum number of\n\t   * pixels the input has to move to trigger this gesture.\n\t   */\n\t  function Pan(options) {\n\t    _classCallCheck(this, Pan);\n\t\n\t    /**\n\t     * The type of the Gesture.\n\t     * @type {String}\n\t     */\n\t    var _this = _possibleConstructorReturn(this, (Pan.__proto__ || Object.getPrototypeOf(Pan)).call(this));\n\t\n\t    _this.type = 'pan';\n\t\n\t    /**\n\t     * The number of inputs to trigger a Pan can be variable,\n\t     * and the maximum number being a factor of the browser.\n\t     * @type {Number}\n\t     */\n\t    _this.numInputs = options && options.numInputs ? options.numInputs : DEFAULT_INPUTS;\n\t\n\t    /**\n\t     * The minimum amount in pixels the pan must move until it is fired.\n\t     * @type {Number}\n\t     */\n\t    _this.threshold = options && options.threshold ? options.threshold : DEFAULT_MIN_THRESHOLD;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Event hook for the start of a gesture. Marks each input as active,\n\t   * so it can invalidate any end events.\n\t   * @param {Array} inputs\n\t   */\n\t\n\t\n\t  _createClass(Pan, [{\n\t    key: 'start',\n\t    value: function start(inputs) {\n\t      var _this2 = this;\n\t\n\t      inputs.forEach(function (input) {\n\t        var progress = input.getGestureProgress(_this2.getId());\n\t        progress.active = true;\n\t        progress.lastEmitted = {\n\t          x: input.current.x,\n\t          y: input.current.y\n\t        };\n\t      });\n\t    }\n\t\n\t    /**\n\t     * move() - Event hook for the move of a gesture.\n\t     * Fired whenever the input length is met, and keeps a boolean flag that\n\t     * the gesture has fired at least once.\n\t     * @param {Array} inputs - The array of Inputs on the screen\n\t     * @param {Object} state - The state object of the current region.\n\t     * @param {Element} element - The element associated to the binding.\n\t     * @return {Object} - Returns the distance in pixels between the two inputs.\n\t     */\n\t\n\t  }, {\n\t    key: 'move',\n\t    value: function move(inputs, state, element) {\n\t      var _this3 = this;\n\t\n\t      if (this.numInputs !== inputs.length) return null;\n\t\n\t      var output = {\n\t        data: []\n\t      };\n\t\n\t      inputs.forEach(function (input, index) {\n\t        var progress = input.getGestureProgress(_this3.getId());\n\t        var distanceFromLastEmit = _util2.default.distanceBetweenTwoPoints(progress.lastEmitted.x, progress.lastEmitted.y, input.current.x, input.current.y);\n\t        var reachedThreshold = distanceFromLastEmit >= _this3.threshold;\n\t\n\t        if (progress.active && reachedThreshold) {\n\t          output.data[index] = packData(input, progress);\n\t          progress.lastEmitted.x = input.current.x;\n\t          progress.lastEmitted.y = input.current.y;\n\t        }\n\t      });\n\t\n\t      return output;\n\t\n\t      function packData(input, progress) {\n\t        var distanceFromOrigin = _util2.default.distanceBetweenTwoPoints(input.initial.x, input.current.x, input.initial.y, input.current.y);\n\t        var directionFromOrigin = _util2.default.getAngle(input.initial.x, input.initial.y, input.current.x, input.current.y);\n\t        var currentDirection = _util2.default.getAngle(progress.lastEmitted.x, progress.lastEmitted.y, input.current.x, input.current.y);\n\t        var change = {\n\t          x: input.current.x - progress.lastEmitted.x,\n\t          y: input.current.y - progress.lastEmitted.y\n\t        };\n\t\n\t        return {\n\t          distanceFromOrigin: distanceFromOrigin,\n\t          directionFromOrigin: directionFromOrigin,\n\t          currentDirection: currentDirection,\n\t          change: change\n\t        };\n\t      }\n\t    }\n\t\n\t    /* move*/\n\t\n\t    /**\n\t     * end() - Event hook for the end of a gesture. If the gesture has at least\n\t     * fired once, then it ends on the first end event such that any remaining\n\t     * inputs will not trigger the event until all inputs have reached the\n\t     * touchend event. Any touchend->touchstart events that occur before all\n\t     * inputs are fully off the screen should not fire.\n\t     * @param {Array} inputs - The array of Inputs on the screen\n\t     * @return {null} - null if the gesture is not to be emitted,\n\t     *  Object with information otherwise.\n\t     */\n\t\n\t  }, {\n\t    key: 'end',\n\t    value: function end(inputs) {\n\t      var _this4 = this;\n\t\n\t      inputs.forEach(function (input) {\n\t        var progress = input.getGestureProgress(_this4.getId());\n\t        progress.active = false;\n\t      });\n\t      return null;\n\t    }\n\t\n\t    /* end*/\n\t\n\t  }]);\n\t\n\t  return Pan;\n\t}(_Gesture3.default);\n\t\n\texports.default = Pan;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Gesture2 = __webpack_require__(4);\n\t\n\tvar _Gesture3 = _interopRequireDefault(_Gesture2);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file Pinch.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Contains the abstract Pinch class\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar DEFAULT_INPUTS = 2;\n\tvar DEFAULT_MIN_THRESHOLD = 1;\n\t\n\t/**\n\t * A Pinch is defined as two inputs moving either together or apart.\n\t * @class Pinch\n\t */\n\t\n\tvar Pinch = function (_Gesture) {\n\t  _inherits(Pinch, _Gesture);\n\t\n\t  /**\n\t   * Constructor function for the Pinch class.\n\t   * @param {Object} options\n\t   */\n\t  function Pinch(options) {\n\t    _classCallCheck(this, Pinch);\n\t\n\t    /**\n\t     * The type of the Gesture.\n\t     * @type {String}\n\t     */\n\t    var _this = _possibleConstructorReturn(this, (Pinch.__proto__ || Object.getPrototypeOf(Pinch)).call(this));\n\t\n\t    _this.type = 'pinch';\n\t\n\t    /**\n\t     * The minimum amount in pixels the inputs must move until it is fired.\n\t     * @type {Number}\n\t     */\n\t    _this.threshold = options && options.threshold ? options.threshold : DEFAULT_MIN_THRESHOLD;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Event hook for the start of a gesture. Initialized the lastEmitted\n\t   * gesture and stores it in the first input for reference events.\n\t   * @param {Array} inputs\n\t   */\n\t\n\t\n\t  _createClass(Pinch, [{\n\t    key: 'start',\n\t    value: function start(inputs, state, element) {\n\t      if (!this.isValid(inputs, state, element)) {\n\t        return null;\n\t      }\n\t      if (inputs.length === DEFAULT_INPUTS) {\n\t        // Store the progress in the first input.\n\t        var progress = inputs[0].getGestureProgress(this.type);\n\t        progress.lastEmittedDistance = _util2.default.distanceBetweenTwoPoints(inputs[0].current.x, inputs[1].current.x, inputs[0].current.y, inputs[1].current.y);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Event hook for the move of a gesture.\n\t     *  Determines if the two points are moved in the expected direction relative\n\t     *  to the current distance and the last distance.\n\t     * @param {Array} inputs - The array of Inputs on the screen.\n\t     * @param {Object} state - The state object of the current region.\n\t     * @param {Element} element - The element associated to the binding.\n\t     * @return {Object | null} - Returns the distance in pixels between two inputs\n\t     */\n\t\n\t  }, {\n\t    key: 'move',\n\t    value: function move(inputs, state, element) {\n\t      if (state.numActiveInputs() === DEFAULT_INPUTS) {\n\t        var currentDistance = _util2.default.distanceBetweenTwoPoints(inputs[0].current.x, inputs[1].current.x, inputs[0].current.y, inputs[1].current.y);\n\t        var centerPoint = _util2.default.getMidpoint(inputs[0].current.x, inputs[1].current.x, inputs[0].current.y, inputs[1].current.y);\n\t\n\t        // Progress is stored in the first input.\n\t        var progress = inputs[0].getGestureProgress(this.type);\n\t        var change = currentDistance - progress.lastEmittedDistance;\n\t\n\t        if (Math.abs(change) >= this.threshold) {\n\t          progress.lastEmittedDistance = currentDistance;\n\t          return {\n\t            distance: currentDistance,\n\t            center: centerPoint,\n\t            change: change\n\t          };\n\t        }\n\t      }\n\t\n\t      return null;\n\t    }\n\t  }]);\n\t\n\t  return Pinch;\n\t}(_Gesture3.default);\n\t\n\texports.default = Pinch;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Gesture2 = __webpack_require__(4);\n\t\n\tvar _Gesture3 = _interopRequireDefault(_Gesture2);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file Rotate.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Contains the Rotate class\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar DEFAULT_INPUTS = 2;\n\t\n\t/**\n\t * A Rotate is defined as two inputs moving about a circle,\n\t * maintaining a relatively equal radius.\n\t * @class Rotate\n\t */\n\t\n\tvar Rotate = function (_Gesture) {\n\t  _inherits(Rotate, _Gesture);\n\t\n\t  /**\n\t   * Constructor function for the Rotate class.\n\t   */\n\t  function Rotate() {\n\t    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t    _classCallCheck(this, Rotate);\n\t\n\t    /**\n\t     * The type of the Gesture.\n\t     * @type {String}\n\t     */\n\t    var _this = _possibleConstructorReturn(this, (Rotate.__proto__ || Object.getPrototypeOf(Rotate)).call(this));\n\t\n\t    _this.type = 'rotate';\n\t\n\t    /**\n\t     * The number of touches required to emit Rotate events.\n\t     * @type {Number}\n\t     */\n\t    _this.numInputs = options.numInputs || DEFAULT_INPUTS;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * move() - Event hook for the move of a gesture. Obtains the midpoint of two\n\t   * the two inputs and calculates the projection of the right most input along\n\t   * a unit circle to obtain an angle. This angle is compared to the previously\n\t   * calculated angle to output the change of distance, and is compared to the\n\t   * initial angle to output the distance from the initial angle to the current\n\t   * angle.\n\t   * @param {Array} inputs - The array of Inputs on the screen\n\t   * @param {Object} state - The state object of the current listener.\n\t   * @param {Element} element - The element associated to the binding.\n\t   * @return {null} - null if this event did not occur\n\t   * @return {Object} obj.angle - The current angle along the unit circle\n\t   * @return {Object} obj.distanceFromOrigin - The angular distance travelled\n\t   * from the initial right most point.\n\t   * @return {Object} obj.distanceFromLast - The change of angle between the\n\t   * last position and the current position.\n\t   */\n\t\n\t\n\t  _createClass(Rotate, [{\n\t    key: 'move',\n\t    value: function move(inputs, state, element) {\n\t      var numActiveInputs = state.numActiveInputs();\n\t      if (this.numInputs !== numActiveInputs) return null;\n\t\n\t      var currentPivot = void 0,\n\t          initialPivot = void 0;\n\t      var input = void 0;\n\t      if (numActiveInputs === 1) {\n\t        var bRect = element.getBoundingClientRect();\n\t        currentPivot = {\n\t          x: bRect.left + bRect.width / 2,\n\t          y: bRect.top + bRect.height / 2\n\t        };\n\t        initialPivot = currentPivot;\n\t        input = inputs[0];\n\t      } else {\n\t        currentPivot = _util2.default.getMidpoint(inputs[0].current.x, inputs[1].current.x, inputs[0].current.y, inputs[1].current.y);\n\t        input = _util2.default.getRightMostInput(inputs);\n\t      }\n\t\n\t      // Translate the current pivot point.\n\t      var currentAngle = _util2.default.getAngle(currentPivot.x, currentPivot.y, input.current.x, input.current.y);\n\t\n\t      var progress = input.getGestureProgress(this.getId());\n\t      if (!progress.initialAngle) {\n\t        progress.initialAngle = progress.previousAngle = currentAngle;\n\t        progress.distance = progress.change = 0;\n\t      } else {\n\t        progress.change = _util2.default.getAngularDistance(progress.previousAngle, currentAngle);\n\t        progress.distance = progress.distance + progress.change;\n\t      }\n\t\n\t      progress.previousAngle = currentAngle;\n\t\n\t      return {\n\t        angle: currentAngle,\n\t        distanceFromOrigin: progress.distance,\n\t        distanceFromLast: progress.change\n\t      };\n\t    }\n\t\n\t    /* move*/\n\t\n\t  }]);\n\t\n\t  return Rotate;\n\t}(_Gesture3.default);\n\t\n\texports.default = Rotate;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Gesture2 = __webpack_require__(4);\n\t\n\tvar _Gesture3 = _interopRequireDefault(_Gesture2);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file Swipe.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Contains the Swipe class\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar DEFAULT_INPUTS = 1;\n\tvar DEFAULT_MAX_REST_TIME = 100;\n\tvar DEFAULT_ESCAPE_VELOCITY = 0.2;\n\tvar DEFAULT_TIME_DISTORTION = 100;\n\tvar DEFAULT_MAX_PROGRESS_STACK = 10;\n\t\n\t/**\n\t * A swipe is defined as input(s) moving in the same direction in an relatively\n\t * increasing velocity and leaving the screen at some point before it drops\n\t * below it's escape velocity.\n\t * @class Swipe\n\t */\n\t\n\tvar Swipe = function (_Gesture) {\n\t  _inherits(Swipe, _Gesture);\n\t\n\t  /**\n\t   * Constructor function for the Swipe class.\n\t   * @param {Object} [options] - The options object.\n\t   * @param {Number} [options.numInputs] - The number of inputs to trigger a\n\t   * Swipe can be variable, and the maximum number being a factor of the browser\n\t   *  move and current move events.\n\t   * @param {Number} [options.maxRestTime] - The maximum resting time a point\n\t   *  has between it's last\n\t   * @param {Number} [options.escapeVelocity] - The minimum velocity the input\n\t   *  has to be at to emit a swipe.\n\t   * @param {Number} [options.timeDistortion] - (EXPERIMENTAL) A value of time\n\t   *  in milliseconds to distort between events.\n\t   * @param {Number} [options.maxProgressStack] - (EXPERIMENTAL)The maximum\n\t   *  amount of move events to keep\n\t   * track of for a swipe.\n\t   */\n\t  function Swipe(options) {\n\t    _classCallCheck(this, Swipe);\n\t\n\t    /**\n\t     * The type of the Gesture\n\t     * @type {String}\n\t     */\n\t    var _this = _possibleConstructorReturn(this, (Swipe.__proto__ || Object.getPrototypeOf(Swipe)).call(this));\n\t\n\t    _this.type = 'swipe';\n\t\n\t    /**\n\t     * The number of inputs to trigger a Swipe can be variable,\n\t     * and the maximum number being a factor of the browser.\n\t     * @type {Number}\n\t     */\n\t    _this.numInputs = options && options.numInputs ? options.numInputs : DEFAULT_INPUTS;\n\t\n\t    /**\n\t     * The maximum resting time a point has between it's last move and\n\t     * current move events.\n\t     * @type {Number}\n\t     */\n\t    _this.maxRestTime = options && options.maxRestTime ? options.maxRestTime : DEFAULT_MAX_REST_TIME;\n\t\n\t    /**\n\t     * The minimum velocity the input has to be at to emit a swipe.\n\t     * This is useful for determining the difference between\n\t     * a swipe and a pan gesture.\n\t     * @type {number}\n\t     */\n\t    _this.escapeVelocity = options && options.escapeVelocity ? options.escapeVelocity : DEFAULT_ESCAPE_VELOCITY;\n\t\n\t    /**\n\t     * (EXPERIMENTAL) A value of time in milliseconds to distort between events.\n\t     * Browsers do not accurately measure time with the Date constructor in\n\t     * milliseconds, so consecutive events sometimes display the same timestamp\n\t     * but different x/y coordinates. This will distort a previous time\n\t     * in such cases by the timeDistortion's value.\n\t     * @type {number}\n\t     */\n\t    _this.timeDistortion = options && options.timeDistortion ? options.timeDistortion : DEFAULT_TIME_DISTORTION;\n\t\n\t    /**\n\t     * (EXPERIMENTAL) The maximum amount of move events to keep track of for a\n\t     * swipe. This helps give a more accurate estimate of the user's velocity.\n\t     * @type {number}\n\t     */\n\t    _this.maxProgressStack = options && options.maxProgressStack ? options.maxProgressStack : DEFAULT_MAX_PROGRESS_STACK;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Event hook for the move of a gesture. Captures an input's x/y coordinates\n\t   * and the time of it's event on a stack.\n\t   * @param {Array} inputs - The array of Inputs on the screen.\n\t   * @param {Object} state - The state object of the current region.\n\t   * @param {Element} element - The element associated to the binding.\n\t   * @return {null} - Swipe does not emit from a move.\n\t   */\n\t\n\t\n\t  _createClass(Swipe, [{\n\t    key: 'move',\n\t    value: function move(inputs, state, element) {\n\t      if (this.numInputs === inputs.length) {\n\t        for (var i = 0; i < inputs.length; i++) {\n\t          var progress = inputs[i].getGestureProgress(this.getId());\n\t          if (!progress.moves) {\n\t            progress.moves = [];\n\t          }\n\t\n\t          progress.moves.push({\n\t            time: new Date().getTime(),\n\t            x: inputs[i].current.x,\n\t            y: inputs[i].current.y\n\t          });\n\t\n\t          if (progress.length > this.maxProgressStack) {\n\t            progress.moves.shift();\n\t          }\n\t        }\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /* move*/\n\t\n\t    /**\n\t     * Determines if the input's history validates a swipe motion.\n\t     * Determines if it did not come to a complete stop (maxRestTime), and if it\n\t     * had enough of a velocity to be considered (ESCAPE_VELOCITY).\n\t     * @param {Array} inputs - The array of Inputs on the screen\n\t     * @return {null|Object} - null if the gesture is not to be emitted,\n\t     *  Object with information otherwise.\n\t     */\n\t\n\t  }, {\n\t    key: 'end',\n\t    value: function end(inputs) {\n\t      if (this.numInputs === inputs.length) {\n\t        var output = {\n\t          data: []\n\t        };\n\t\n\t        for (var i = 0; i < inputs.length; i++) {\n\t          // Determine if all input events are on the 'end' event.\n\t          if (inputs[i].current.type !== 'end') {\n\t            return;\n\t          }\n\t\n\t          var progress = inputs[i].getGestureProgress(this.getId());\n\t          if (progress.moves && progress.moves.length > 2) {\n\t            // CHECK : Return if the input has not moved in maxRestTime ms.\n\t\n\t            var currentMove = progress.moves.pop();\n\t            if (new Date().getTime() - currentMove.time > this.maxRestTime) {\n\t              return null;\n\t            }\n\t\n\t            var lastMove = void 0;\n\t            var index = progress.moves.length - 1;\n\t\n\t            /* Date is unreliable, so we retrieve the last move event where\n\t             the time is not the same. */\n\t            while (index !== -1) {\n\t              if (progress.moves[index].time !== currentMove.time) {\n\t                lastMove = progress.moves[index];\n\t                break;\n\t              }\n\t\n\t              index--;\n\t            }\n\t\n\t            /* If the date is REALLY unreliable, we apply a time distortion\n\t             to the last event.\n\t             */\n\t            if (!lastMove) {\n\t              lastMove = progress.moves.pop();\n\t              lastMove.time += this.timeDistortion;\n\t            }\n\t\n\t            var velocity = _util2.default.getVelocity(lastMove.x, lastMove.y, lastMove.time, currentMove.x, currentMove.y, currentMove.time);\n\t\n\t            output.data[i] = {\n\t              velocity: velocity,\n\t              distance: _util2.default.distanceBetweenTwoPoints(lastMove.x, currentMove.x, lastMove.y, currentMove.y),\n\t              duration: currentMove.time - lastMove.time,\n\t              currentDirection: _util2.default.getAngle(lastMove.x, lastMove.y, currentMove.x, currentMove.y)\n\t            };\n\t          }\n\t        }\n\t\n\t        for (var i = 0; i < output.data.length; i++) {\n\t          if (velocity < this.escapeVelocity) {\n\t            return null;\n\t          }\n\t        }\n\t\n\t        if (output.data.length > 0) {\n\t          return output;\n\t        }\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /* end*/\n\t\n\t  }]);\n\t\n\t  return Swipe;\n\t}(_Gesture3.default);\n\t\n\texports.default = Swipe;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Gesture2 = __webpack_require__(4);\n\t\n\tvar _Gesture3 = _interopRequireDefault(_Gesture2);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file Tap.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Contains the Tap class\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar DEFAULT_MIN_DELAY_MS = 0;\n\tvar DEFAULT_MAX_DELAY_MS = 300;\n\tvar DEFAULT_INPUTS = 1;\n\tvar DEFAULT_MOVE_PX_TOLERANCE = 10;\n\t\n\t/**\n\t * A Tap is defined as a touchstart to touchend event in quick succession.\n\t * @class Tap\n\t */\n\t\n\tvar Tap = function (_Gesture) {\n\t  _inherits(Tap, _Gesture);\n\t\n\t  /**\n\t   * Constructor function for the Tap class.\n\t   * @param {Object} [options] - The options object.\n\t   * @param {Number} [options.minDelay=0] - The minimum delay between a\n\t   * touchstart and touchend can be configured in milliseconds.\n\t   * @param {Number} [options.maxDelay=300] - The maximum delay between a\n\t   * touchstart and touchend can be configured in milliseconds.\n\t   * @param {Number} [options.numInputs=1] - Number of inputs for Tap gesture.\n\t   * @param {Number} [options.tolerance=10] - The tolerance in pixels\n\t   *  a user can move.\n\t   */\n\t  function Tap(options) {\n\t    _classCallCheck(this, Tap);\n\t\n\t    /**\n\t     * The type of the Gesture.\n\t     * @type {String}\n\t     */\n\t    var _this = _possibleConstructorReturn(this, (Tap.__proto__ || Object.getPrototypeOf(Tap)).call(this));\n\t\n\t    _this.type = 'tap';\n\t\n\t    /**\n\t     * The minimum amount between a touchstart and a touchend can be configured\n\t     * in milliseconds. The minimum delay starts to count down when the expected\n\t     * number of inputs are on the screen, and ends when ALL inputs are off the\n\t     * screen.\n\t     * @type {Number}\n\t     */\n\t    _this.minDelay = options && options.minDelay ? options.minDelay : DEFAULT_MIN_DELAY_MS;\n\t\n\t    /**\n\t     * The maximum delay between a touchstart and touchend can be configured in\n\t     * milliseconds. The maximum delay starts to count down when the expected\n\t     * number of inputs are on the screen, and ends when ALL inputs are off the\n\t     * screen.\n\t     * @type {Number}\n\t     */\n\t    _this.maxDelay = options && options.maxDelay ? options.maxDelay : DEFAULT_MAX_DELAY_MS;\n\t\n\t    /**\n\t     * The number of inputs to trigger a Tap can be variable,\n\t     * and the maximum number being a factor of the browser.\n\t     * @type {Number}\n\t     */\n\t    _this.numInputs = options && options.numInputs ? options.numInputs : DEFAULT_INPUTS;\n\t\n\t    /**\n\t     * A move tolerance in pixels allows some slop between a user's start to end\n\t     * events. This allows the Tap gesture to be triggered more easily.\n\t     * @type {number}\n\t     */\n\t    _this.tolerance = options && options.tolerance ? options.tolerance : DEFAULT_MOVE_PX_TOLERANCE;\n\t    return _this;\n\t  }\n\t\n\t  /* constructor*/\n\t\n\t  /**\n\t   * Event hook for the start of a gesture. Keeps track of when the inputs\n\t   * trigger the start event.\n\t   * @param {Array} inputs - The array of Inputs on the screen.\n\t   * @return {null} - Tap does not trigger on a start event.\n\t   */\n\t\n\t\n\t  _createClass(Tap, [{\n\t    key: 'start',\n\t    value: function start(inputs) {\n\t      var _this2 = this;\n\t\n\t      if (inputs.length === this.numInputs) {\n\t        inputs.forEach(function (input) {\n\t          var progress = input.getGestureProgress(_this2.type);\n\t          progress.start = new Date().getTime();\n\t        });\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /* start*/\n\t\n\t    /**\n\t     * Event hook for the move of a gesture. The Tap event reaches here if the\n\t     * user starts to move their input before an 'end' event is reached.\n\t     * @param {Array} inputs - The array of Inputs on the screen.\n\t     * @param {Object} state - The state object of the current region.\n\t     * @param {Element} element - The element associated to the binding.\n\t     * @return {null} - Tap does not trigger on a move event.\n\t     */\n\t\n\t  }, {\n\t    key: 'move',\n\t    value: function move(inputs, state, element) {\n\t      var _this3 = this;\n\t\n\t      for (var i = 0; i < inputs.length; i++) {\n\t        if (inputs[i].getCurrentEventType() === 'move') {\n\t          var current = inputs[i].current;\n\t          var previous = inputs[i].previous;\n\t          if (!_util2.default.isWithin(current.x, current.y, previous.x, previous.y, this.tolerance)) {\n\t            var _ret = function () {\n\t              var type = _this3.type;\n\t              inputs.forEach(function (input) {\n\t                input.resetProgress(type);\n\t              });\n\t\n\t              return {\n\t                v: null\n\t              };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t          }\n\t        }\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /* move*/\n\t\n\t    /**\n\t     * Event hook for the end of a gesture.\n\t     * Determines if this the tap event can be fired if the delay and tolerance\n\t     * constraints are met. Also waits for all of the inputs to be off the screen\n\t     * before determining if the gesture is triggered.\n\t     * @param {Array} inputs - The array of Inputs on the screen.\n\t     * @return {null|Object} - null if the gesture is not to be emitted,\n\t     * Object with information otherwise. Returns the interval time between start\n\t     * and end events.\n\t     */\n\t\n\t  }, {\n\t    key: 'end',\n\t    value: function end(inputs) {\n\t      if (inputs.length !== this.numInputs) {\n\t        return null;\n\t      }\n\t\n\t      var startTime = Number.MAX_VALUE;\n\t      for (var i = 0; i < inputs.length; i++) {\n\t        if (inputs[i].getCurrentEventType() !== 'end') {\n\t          return null;\n\t        }\n\t\n\t        var progress = inputs[i].getGestureProgress(this.type);\n\t        if (!progress.start) {\n\t          return null;\n\t        }\n\t\n\t        // Find the most recent input's startTime\n\t        if (progress.start < startTime) {\n\t          startTime = progress.start;\n\t        }\n\t      }\n\t\n\t      var interval = new Date().getTime() - startTime;\n\t      if (this.minDelay <= interval && this.maxDelay >= interval) {\n\t        return {\n\t          interval: interval\n\t        };\n\t      } else {\n\t        var type = this.type;\n\t        inputs.forEach(function (input) {\n\t          input.resetProgress(type);\n\t        });\n\t\n\t        return null;\n\t      }\n\t    }\n\t\n\t    /* end*/\n\t\n\t  }]);\n\t\n\t  return Tap;\n\t}(_Gesture3.default);\n\t\n\texports.default = Tap;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @file Binding.js\n\t */\n\t\n\t/**\n\t * Responsible for creating a binding between an element and a gesture.\n\t * @class Binding\n\t */\n\tvar Binding =\n\t/**\n\t * Constructor function for the Binding class.\n\t * @param {Element} element - The element to associate the gesture to.\n\t * @param {Gesture} gesture - A instance of the Gesture type.\n\t * @param {Function} handler - The function handler to execute when a\n\t * gesture is recognized\n\t * on the associated element.\n\t * @param {Boolean} [capture=false] - A boolean signifying if the event is\n\t * to be emitted during\n\t * the capture or bubble phase.\n\t * @param {Boolean} [bindOnce=false] - A boolean flag\n\t * used for the bindOnce syntax.\n\t */\n\tfunction Binding(element, gesture, handler, capture, bindOnce) {\n\t  _classCallCheck(this, Binding);\n\t\n\t  /**\n\t   * The element to associate the gesture to.\n\t   * @type {Element}\n\t   */\n\t  this.element = element;\n\t  /**\n\t   * A instance of the Gesture type.\n\t   * @type {Gesture}\n\t   */\n\t  this.gesture = gesture;\n\t  /**\n\t   * The function handler to execute when a gesture is\n\t   * recognized on the associated element.\n\t   * @type {Function}\n\t   */\n\t  this.handler = handler;\n\t\n\t  /**\n\t   * A boolean signifying if the event is to be\n\t   * emitted during the capture or bubble phase.\n\t   * @type {Boolean}\n\t   */\n\t  this.capture = typeof capture !== 'undefined' ? capture : false;\n\t\n\t  /**\n\t   * A boolean flag used for the bindOnce syntax.\n\t   * @type {Boolean}\n\t   */\n\t  this.bindOnce = typeof bindOnce !== 'undefined' ? bindOnce : false;\n\t};\n\t\n\texports.default = Binding;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @file Input.js\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\tvar _ZingEvent = __webpack_require__(17);\n\t\n\tvar _ZingEvent2 = _interopRequireDefault(_ZingEvent);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Tracks a single input and contains information about the\n\t * current, previous, and initial events.\n\t * Contains the progress of each Input and it's associated gestures.\n\t * @class Input\n\t */\n\tvar Input = function () {\n\t\n\t  /**\n\t   * Constructor function for the Input class.\n\t   * @param {Event} event - The Event object from the window\n\t   * @param {Number} [identifier=0] - The identifier for each input event\n\t   * (taken from event.changedTouches)\n\t   */\n\t  function Input(event, identifier) {\n\t    _classCallCheck(this, Input);\n\t\n\t    var currentEvent = new _ZingEvent2.default(event, identifier);\n\t\n\t    /**\n\t     * Holds the initial event object. A touchstart/mousedown event.\n\t     * @type {ZingEvent}\n\t     */\n\t    this.initial = currentEvent;\n\t\n\t    /**\n\t     * Holds the most current event for this Input, disregarding any other past,\n\t     * current, and future events that other Inputs participate in.\n\t     * e.g. This event ended in an 'end' event, but another Input is still\n\t     * participating in events -- this will not be updated in such cases.\n\t     * @type {ZingEvent}\n\t     */\n\t    this.current = currentEvent;\n\t\n\t    /**\n\t     * Holds the previous event that took place.\n\t     * @type {ZingEvent}\n\t     */\n\t    this.previous = currentEvent;\n\t\n\t    /**\n\t     * Refers to the event.touches index, or 0 if a simple mouse event occurred.\n\t     * @type {Number}\n\t     */\n\t    this.identifier = typeof identifier !== 'undefined' ? identifier : 0;\n\t\n\t    /**\n\t     * Stores internal state between events for\n\t     * each gesture based off of the gesture's id.\n\t     * @type {Object}\n\t     */\n\t    this.progress = {};\n\t  }\n\t\n\t  /**\n\t   * Receives an input, updates the internal state of what the input has done.\n\t   * @param {Event} event - The event object to wrap with a ZingEvent.\n\t   * @param {Number} touchIdentifier - The index of inputs, from event.touches\n\t   */\n\t\n\t\n\t  _createClass(Input, [{\n\t    key: 'update',\n\t    value: function update(event, touchIdentifier) {\n\t      this.previous = this.current;\n\t      this.current = new _ZingEvent2.default(event, touchIdentifier);\n\t    }\n\t\n\t    /**\n\t     * Returns the progress of the specified gesture.\n\t     * @param {String} id - The identifier for each unique Gesture's progress.\n\t     * @return {Object} - The progress of the gesture.\n\t     * Creates an empty object if no progress has begun.\n\t     */\n\t\n\t  }, {\n\t    key: 'getGestureProgress',\n\t    value: function getGestureProgress(id) {\n\t      if (!this.progress[id]) {\n\t        this.progress[id] = {};\n\t      }\n\t      return this.progress[id];\n\t    }\n\t\n\t    /**\n\t     * Returns the normalized current Event's type.\n\t     * @return {String} The current event's type ( start | move | end )\n\t     */\n\t\n\t  }, {\n\t    key: 'getCurrentEventType',\n\t    value: function getCurrentEventType() {\n\t      return this.current.type;\n\t    }\n\t\n\t    /**\n\t     * Resets a progress/state object of the specified gesture.\n\t     * @param {String} id - The identifier of the specified gesture\n\t     */\n\t\n\t  }, {\n\t    key: 'resetProgress',\n\t    value: function resetProgress(id) {\n\t      this.progress[id] = {};\n\t    }\n\t  }]);\n\t\n\t  return Input;\n\t}();\n\t\n\texports.default = Input;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar _util2 = _interopRequireDefault(_util);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n\t                                                                                                                                                           * @file ZingEvent.js\n\t                                                                                                                                                           * Contains logic for ZingEvents\n\t                                                                                                                                                           */\n\t\n\tvar INITIAL_COORDINATE = 0;\n\t/**\n\t * An event wrapper that normalizes events across browsers and input devices\n\t * @class ZingEvent\n\t */\n\t\n\tvar ZingEvent =\n\t/**\n\t * @constructor\n\t * @param {Event} event - The event object being wrapped.\n\t * @param {Array} event.touches - The number of touches on\n\t *  a screen (mobile only).\n\t * @param {Object} event.changedTouches - The TouchList representing\n\t * points that participated in the event.\n\t * @param {Number} touchIdentifier - The index of touch if applicable\n\t */\n\tfunction ZingEvent(event, touchIdentifier) {\n\t  _classCallCheck(this, ZingEvent);\n\t\n\t  /**\n\t   * The original event object.\n\t   * @type {Event}\n\t   */\n\t  this.originalEvent = event;\n\t\n\t  /**\n\t   * The type of event or null if it is an event not predetermined.\n\t   * @see util.normalizeEvent\n\t   * @type {String | null}\n\t   */\n\t  this.type = _util2.default.normalizeEvent[event.type];\n\t\n\t  /**\n\t   * The X coordinate for the event, based off of the client.\n\t   * @type {number}\n\t   */\n\t  this.x = INITIAL_COORDINATE;\n\t\n\t  /**\n\t   * The Y coordinate for the event, based off of the client.\n\t   * @type {number}\n\t   */\n\t  this.y = INITIAL_COORDINATE;\n\t\n\t  var eventObj = void 0;\n\t  if (event.touches && event.changedTouches) {\n\t    eventObj = Array.from(event.changedTouches).find(function (t) {\n\t      return t.identifier === touchIdentifier;\n\t    });\n\t  } else {\n\t    eventObj = event;\n\t  }\n\t\n\t  this.x = this.clientX = eventObj.clientX;\n\t  this.y = this.clientY = eventObj.clientY;\n\t\n\t  this.pageX = eventObj.pageX;\n\t  this.pageY = eventObj.pageY;\n\t\n\t  this.screenX = eventObj.screenX;\n\t  this.screenY = eventObj.screenY;\n\t};\n\t\n\texports.default = ZingEvent;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ./dist/zingtouch.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 213b465cde89201be945","/**\n * @file main.js\n * Main file to setup event listeners on the document,\n * and to expose the ZingTouch object\n */\n\nimport ZingTouch from './../ZingTouch.js';\nwindow.ZingTouch = ZingTouch;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/main.js","/**\n * @file ZingTouch.js\n * Main object containing API methods and Gesture constructors\n */\n\nimport Region from './core/classes/Region.js';\nimport Gesture from './gestures/Gesture.js';\nimport Pan from './gestures/Pan.js';\nimport Pinch from './gestures/Pinch.js';\nimport Rotate from './gestures/Rotate.js';\nimport Swipe from './gestures/Swipe.js';\nimport Tap from './gestures/Tap.js';\n\n/**\n * The global API interface for ZingTouch. Contains a constructor for the\n * Region Object, and constructors for each predefined Gesture.\n * @type {Object}\n * @namespace ZingTouch\n */\nlet ZingTouch = {\n  _regions: [],\n\n  // Constructors\n  Gesture: Gesture,\n  Pan: Pan,\n  Pinch: Pinch,\n  Rotate: Rotate,\n  Swipe: Swipe,\n  Tap: Tap,\n  Region: function(element, capture, preventDefault) {\n    let id = ZingTouch._regions.length;\n    let region = new Region(element, capture, preventDefault, id);\n    ZingTouch._regions.push(region);\n    return region;\n  },\n};\n\nexport default ZingTouch;\n\n\n\n// WEBPACK FOOTER //\n// ./src/ZingTouch.js","/**\n * @file Region.js\n */\n\nimport Binder from './Binder.js';\nimport Gesture from './../../gestures/Gesture.js';\nimport arbiter from './../arbiter.js';\nimport State from './State.js';\n\n/**\n * Allows the user to specify a region to capture all events to feed ZingTouch\n * into. This can be as narrow as the element itself, or as big as the document\n * itself. The more specific an area, the better performant the overall\n * application will perform. Contains API methods to bind/unbind specific\n * elements to corresponding gestures. Also contains the ability to\n * register/unregister new gestures.\n * @class Region\n */\nclass Region {\n\n  /**\n   * Constructor function for the Region class.\n   * @param {Element} element - The element to capture all\n   *  window events in that region to feed into ZingTouch.\n   * @param {boolean} [capture=false] - Whether the region listens for\n   *  captures or bubbles.\n   * @param {boolean} [preventDefault=true] - Whether the default browser\n   *  functionality should be disabled;\n   * @param {Number} id - The id of the region, assigned by the ZingTouch object\n   */\n  constructor(element, capture, preventDefault, id) {\n    /**\n     * The identifier for the Region. This is assigned by the ZingTouch object\n     * and is used to hash gesture id for uniqueness.\n     * @type {Number}\n     */\n    this.id = id;\n\n    /**\n     * The element being bound to.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the region listens for captures or bubbles.\n     * @type {boolean}\n     */\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\n\n    /**\n     * Boolean to disable browser functionality such as scrolling and zooming\n     * over the region\n     * @type {boolean}\n     */\n    this.preventDefault = (typeof preventDefault !== 'undefined') ?\n      preventDefault : true;\n\n    /**\n     * The internal state object for a Region.\n     * Keeps track of registered gestures, inputs, and events.\n     * @type {State}\n     */\n    this.state = new State(id);\n\n    let eventNames = [];\n    if (window.PointerEvent && !window.TouchEvent) {\n      eventNames = [\n        'pointerdown',\n        'pointermove',\n        'pointerup',\n      ];\n    } else {\n      eventNames = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'touchstart',\n        'touchmove',\n        'touchend',\n      ];\n    }\n\n    // Bind detected browser events to the region element.\n    eventNames.forEach((name) => {\n      element.addEventListener(name, (e) => {\n        arbiter(e, this);\n      }, this.capture);\n    });\n  }\n\n  /**\n   * Bind an element to a registered/unregistered gesture with\n   * multiple function signatures.\n   * @example\n   * bind(element) - chainable\n   * @example\n   * bind(element, gesture, handler, [capture])\n   * @param {Element} element - The element object.\n   * @param {String|Object} [gesture] - Gesture key, or a Gesture object.\n   * @param {Function} [handler] - The function to execute when an event is\n   *  emitted.\n   * @param {Boolean} [capture] - capture/bubble\n   * @param {Boolean} [bindOnce = false] - Option to bind once and\n   *  only emit the event once.\n   * @return {Object} - a chainable object that has the same function as bind.\n   */\n  bind(element, gesture, handler, capture, bindOnce) {\n    if (!element || (element && !element.tagName)) {\n      throw 'Bind must contain an element';\n    }\n\n    bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\n    if (!gesture) {\n      return new Binder(element, bindOnce, this.state);\n    } else {\n      this.state.addBinding(element, gesture, handler, capture, bindOnce);\n    }\n  }\n\n  /**\n   * Bind an element and sets up actions to remove the binding once\n   * it has been emitted for the first time.\n   * 1. bind(element) - chainable\n   * 2. bind(element, gesture, handler, [capture])\n   * @param {Element} element - The element object.\n   * @param {String|Object} gesture - Gesture key, or a Gesture object.\n   * @param {Function} handler - The function to execute when an\n   *  event is emitted.\n   * @param {Boolean} capture - capture/bubble\n   * @return {Object} - a chainable object that has the same function as bind.\n   */\n  bindOnce(element, gesture, handler, capture) {\n    this.bind(element, gesture, handler, capture, true);\n  }\n\n  /**\n   * Unbinds an element from either the specified gesture\n   *  or all if no element is specified.\n   * @param {Element} element -The element to remove.\n   * @param {String | Object} [gesture] - A String representing the gesture,\n   *   or the actual object being used.\n   * @return {Array} - An array of Bindings that were unbound to the element;\n   */\n  unbind(element, gesture) {\n    let bindings = this.state.retrieveBindingsByElement(element);\n    let unbound = [];\n\n    bindings.forEach((binding) => {\n      if (gesture) {\n        if (typeof gesture === 'string' &&\n          this.state.registeredGestures[gesture]) {\n          let registeredGesture = this.state.registeredGestures[gesture];\n          if (registeredGesture.id === binding.gesture.id) {\n            element.removeEventListener(\n              binding.gesture.getId(),\n              binding.handler, binding.capture);\n            unbound.push(binding);\n          }\n        }\n      } else {\n        element.removeEventListener(\n          binding.gesture.getId(),\n          binding.handler,\n          binding.capture);\n        unbound.push(binding);\n      }\n    });\n\n    return unbound;\n  }\n\n  /* unbind*/\n\n  /**\n   * Registers a new gesture with an assigned key\n   * @param {String} key - The key used to register an element to that gesture\n   * @param {Gesture} gesture - A gesture object\n   */\n  register(key, gesture) {\n    if (typeof key !== 'string') {\n      throw new Error('Parameter key is an invalid string');\n    }\n\n    if (!gesture instanceof Gesture) {\n      throw new Error('Parameter gesture is an invalid Gesture object');\n    }\n\n    gesture.setType(key);\n    this.state.registerGesture(gesture, key);\n  }\n\n  /* register*/\n\n  /**\n   * Un-registers a gesture from the Region's state such that\n   * it is no longer emittable.\n   * Unbinds all events that were registered with the type.\n   * @param {String|Object} key - Gesture key that was used to\n   *  register the object\n   * @return {Object} - The Gesture object that was unregistered\n   *  or null if it could not be found.\n   */\n  unregister(key) {\n    this.state.bindings.forEach((binding) => {\n      if (binding.gesture.getType() === key) {\n        binding.element.removeEventListener(binding.gesture.getId(),\n          binding.handler, binding.capture);\n      }\n    });\n\n    let registeredGesture = this.state.registeredGestures[key];\n    delete this.state.registeredGestures[key];\n    return registeredGesture;\n  }\n}\n\nexport default Region;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Region.js","/**\n * @file Binder.js\n */\n\n/**\n * A chainable object that contains a single element to be bound upon.\n * Called from ZingTouch.bind(), and is used to chain over gesture callbacks.\n * @class\n */\nclass Binder {\n  /**\n   * Constructor function for the Binder class.\n   * @param {Element} element - The element to bind gestures to.\n   * @param {Boolean} bindOnce - Option to bind once and only emit\n   * the event once.\n   * @param {Object} state - The state of the Region that is being bound to.\n   * @return {Object} - Returns 'this' to be chained over and over again.\n   */\n  constructor(element, bindOnce, state) {\n    /**\n     * The element to bind gestures to.\n     * @type {Element}\n     */\n    this.element = element;\n\n    Object.keys(state.registeredGestures).forEach((key) => {\n      this[key] = (handler, capture) => {\n        state.addBinding(this.element, key, handler, capture, bindOnce);\n        return this;\n      };\n    });\n  }\n\n}\n\nexport default Binder;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Binder.js","/**\n * @file Gesture.js\n * Contains the Gesture class\n */\n\nimport util from './../core/util.js';\n\n/**\n * The Gesture class that all gestures inherit from.\n */\nclass Gesture {\n  /**\n   * Constructor function for the Gesture class.\n   * @class Gesture\n   */\n  constructor() {\n    /**\n     * The generic string type of gesture ('expand'|'pan'|'pinch'|\n     *  'rotate'|'swipe'|'tap').\n     * @type {String}\n     */\n    this.type = null;\n\n    /**\n     * The unique identifier for each gesture determined at bind time by the\n     * state object. This allows for distinctions across instance variables of\n     * Gestures that are created on the fly (e.g. Tap-1, Tap-2, etc).\n     * @type {String|null}\n     */\n    this.id = null;\n  }\n\n  /**\n   * Set the type of the gesture to be called during an event\n   * @param {String} type - The unique identifier of the gesture being created.\n   */\n  setType(type) {\n    this.type = type;\n  }\n\n  /**\n   * getType() - Returns the generic type of the gesture\n   * @return {String} - The type of gesture\n   */\n  getType() {\n    return this.type;\n  }\n\n  /**\n   * Set the id of the gesture to be called during an event\n   * @param {String} id - The unique identifier of the gesture being created.\n   */\n  setId(id) {\n    this.id = id;\n  }\n\n  /**\n   * Return the id of the event. If the id does not exist, return the type.\n   * @return {String}\n   */\n  getId() {\n    return (this.id !== null) ? this.id : this.type;\n  }\n\n  /**\n   * Updates internal properties with new ones, only if the properties exist.\n   * @param {Object} object\n   */\n  update(object) {\n    Object.keys(object).forEach( key => {\n      this[key] = object[key];\n    });\n  }\n\n  /**\n   * start() - Event hook for the start of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n\t * @param {Object} state - The state object of the current region.\n\t * @param {Element} element - The element associated to the binding.\n   * @return {null|Object}  - Default of null\n   */\n  start(inputs, state, element) {\n    return null;\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null|Object} - Default of null\n   */\n  move(inputs, state, element) {\n    return null;\n  }\n\n  /**\n   * end() - Event hook for the move of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null|Object}  - Default of null\n   */\n  end(inputs) {\n    return null;\n  }\n\n\t/**\n\t* isValid() - Pre-checks to ensure the invariants of a gesture are satisfied.\n\t* @param {Array} inputs - The array of Inputs on the screen\n\t* @param {Object} state - The state object of the current region.\n\t* @param {Element} element - The element associated to the binding.\n\t* @return {boolean} - If the gesture is valid\n\t*/\n\tisValid(inputs, state, element) {\n    return inputs.every( input => {\n        return util.isInside(input.initial.x, input.initial.y, element);\n    });\n  }\n\n}\n\nexport default Gesture;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Gesture.js","/**\n * @file util.js\n * Various accessor and mutator functions to handle state and validation.\n */\n\nconst CIRCLE_DEGREES = 360;\nconst HALF_CIRCLE_DEGREES = 180;\n\n/**\n *  Contains generic helper functions\n * @type {Object}\n * @namespace util\n */\nlet util = {\n\n  /**\n   * Normalizes window events to be either of type start, move, or end.\n   * @param {String} type - The event type emitted by the browser\n   * @return {null|String} - The normalized event, or null if it is an\n   * event not predetermined.\n   */\n  normalizeEvent: Object.freeze({\n      mousedown:   'start',\n      touchstart:  'start',\n      pointerdown: 'start',\n\n      mousemove:   'move',\n      touchmove:   'move',\n      pointermove: 'move',\n\n      mouseup:   'end',\n      touchend:  'end',\n      pointerup: 'end',\n  }),\n  /* normalizeEvent*/\n\n  /**\n   * Determines if the current and previous coordinates are within or\n   * up to a certain tolerance.\n   * @param {Number} currentX - Current event's x coordinate\n   * @param {Number} currentY - Current event's y coordinate\n   * @param {Number} previousX - Previous event's x coordinate\n   * @param {Number} previousY - Previous event's y coordinate\n   * @param {Number} tolerance - The tolerance in pixel value.\n   * @return {boolean} - true if the current coordinates are\n   * within the tolerance, false otherwise\n   */\n  isWithin(currentX, currentY, previousX, previousY, tolerance) {\n    return ((Math.abs(currentY - previousY) <= tolerance) &&\n    (Math.abs(currentX - previousX) <= tolerance));\n  },\n  /* isWithin*/\n\n  /**\n   * Calculates the distance between two points.\n   * @param {Number} x0\n   * @param {Number} x1\n   * @param {Number} y0\n   * @param {Number} y1\n   * @return {number} The numerical value between two points\n   */\n  distanceBetweenTwoPoints(x0, x1, y0, y1) {\n    let dist = (Math.sqrt(((x1 - x0) * (x1 - x0)) + ((y1 - y0) * (y1 - y0))));\n    return Math.round(dist * 100) / 100;\n  },\n\n  /**\n   * Calculates the midpoint coordinates between two points.\n   * @param {Number} x0\n   * @param {Number} x1\n   * @param {Number} y0\n   * @param {Number} y1\n   * @return {Object} The coordinates of the midpoint.\n   */\n  getMidpoint(x0, x1, y0, y1) {\n    return {\n      x: ((x0 + x1) / 2),\n      y: ((y0 + y1) / 2),\n    };\n  },\n  /**\n   * Calculates the angle between the projection and an origin point.\n   *   |                (projectionX,projectionY)\n   *   |             /\n   *   |          /\n   *   |       /\n   *   |    / \n   *   | /__________\n   *    (originX, originY)\n   * @param {number} originX\n   * @param {number} originY\n   * @param {number} projectionX\n   * @param {number} projectionY\n   * @return {number} - Degree along the unit circle where the project lies\n   */\n  getAngle(originX, originY, projectionX, projectionY) {\n    let angle = Math.atan2(projectionY - originY, projectionX - originX) *\n      ((HALF_CIRCLE_DEGREES) / Math.PI);\n    return CIRCLE_DEGREES - ((angle < 0) ? (CIRCLE_DEGREES + angle) : angle);\n  },\n  /**\n   * Calculates the angular distance in degrees between two angles\n   *  along the unit circle\n   * @param {number} start - The starting point in degrees\n   * @param {number} end - The ending point in degrees\n   * @return {number} The number of degrees between the\n   * starting point and ending point. Negative degrees denote a clockwise\n   * direction, and positive a counter-clockwise direction.\n   */\n  getAngularDistance(start, end) {\n    let angle = (end - start) % CIRCLE_DEGREES;\n    let sign = (angle < 0) ? 1 : -1;\n    angle = Math.abs(angle);\n    return (angle > HALF_CIRCLE_DEGREES) ?\n    sign * (CIRCLE_DEGREES - angle) : sign * angle;\n  },\n\n  /**\n   * Calculates the velocity of pixel/milliseconds between two points\n   * @param {Number} startX\n   * @param {Number} startY\n   * @param {Number} startTime\n   * @param {Number} endX\n   * @param {Number} endY\n   * @param {Number} endTime\n   * @return {Number} velocity of px/time\n   */\n  getVelocity(startX, startY, startTime, endX, endY, endTime) {\n    let distance = this.distanceBetweenTwoPoints(startX, endX, startY, endY);\n    return (distance / (endTime - startTime));\n  },\n\n  /**\n   * Returns the farthest right input\n   * @param {Array} inputs\n   * @return {Object}\n   */\n  getRightMostInput(inputs) {\n    let rightMost = null;\n    let distance = Number.MIN_VALUE;\n    inputs.forEach((input) => {\n      if (input.initial.x > distance) {\n        rightMost = input;\n      }\n    });\n    return rightMost;\n  },\n\n  /**\n   * Determines is the value is an integer and not a floating point\n   * @param {Mixed} value\n   * @return {boolean}\n   */\n  isInteger(value) {\n    return (typeof value === 'number') && (value % 1 === 0);\n  },\n\n  /**\n   * Determines if the x,y position of the input is within then target.\n   * @param {Number} x -clientX\n   * @param {Number} y -clientY\n   * @param {Element} target\n   * @return {Boolean}\n   */\n  isInside(x, y, target) {\n    const rect = target.getBoundingClientRect();\n    return ((x > rect.left && x < rect.left + rect.width) &&\n    (y > rect.top && y < rect.top + rect.height));\n  },\n  /**\n   * Polyfill for event.propagationPath\n   * @param {Event} event\n   * @return {Array}\n   */\n  getPropagationPath(event) {\n    if (event.path) {\n      return event.path;\n    } else {\n      let path = [];\n      let node = event.target;\n      while (node != document) {\n        path.push(node);\n        node = node.parentNode;\n      }\n\n      return path;\n    }\n  },\n\n  /**\n   * Retrieve the index inside the path array\n   * @param {Array} path\n   * @param {Element} element\n   * @return {Element}\n   */\n  getPathIndex(path, element) {\n    let index = path.length;\n\n    path.forEach((obj, i) => {\n      if (obj === element) {\n        index = i;\n      }\n    });\n\n    return index;\n  },\n\n  setMSPreventDefault(element) {\n    element.style['-ms-content-zooming'] = 'none';\n    element.style['touch-action'] = 'none';\n  },\n\n  removeMSPreventDefault(element) {\n    element.style['-ms-content-zooming'] = '';\n    element.style['touch-action'] = '';\n  },\n\n  preventDefault(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  }\n};\n\nexport default util;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/util.js","/**\n * @file arbiter.js\n * Contains logic for the dispatcher\n */\n\nimport dispatcher from './dispatcher.js';\nimport interpreter from './interpreter.js';\nimport util from './util.js';\n\n/**\n * Function that handles event flow, negotiating with the interpreter,\n * and dispatcher.\n * 1. Receiving all touch events in the window.\n * 2. Determining which gestures are linked to the target element.\n * 3. Negotiating with the Interpreter what event should occur.\n * 4. Sending events to the dispatcher to emit events to the target.\n * @param {Event} event - The event emitted from the window object.\n * @param {Object} region - The region object of the current listener.\n */\nfunction arbiter(event, region) {\n  const state = region.state;\n  const eventType = util.normalizeEvent[ event.type ];\n\n  /*\n   Return if a gesture is not in progress and won't be. Also catches the case\n   where a previous event is in a partial state (2 finger pan, waits for both\n   inputs to reach touchend)\n   */\n  if (state.inputs.length === 0 && eventType !== 'start') {\n    return;\n  }\n\n  /*\n   Check for 'stale' or events that lost focus\n   (e.g. a pan goes off screen/off region.)\n   Does not affect mobile devices.\n   */\n  if (typeof event.buttons !== 'undefined' &&\n    eventType !== 'end' &&\n    event.buttons === 0) {\n    state.resetInputs();\n    return;\n  }\n\n  // Update the state with the new events. If the event is stopped, return;\n  if (!state.updateInputs(event, region.element)) {\n    return;\n  }\n\n  // Retrieve the initial target from any one of the inputs\n  const bindings = state.retrieveBindingsByInitialPos();\n  if (bindings.length > 0) {\n    if (region.preventDefault) {\n      util.setMSPreventDefault(region.element);\n      util.preventDefault(event);\n    } else {\n      util.removeMSPreventDefault(region.element);\n    }\n\n    const toBeDispatched = {};\n    const gestures = interpreter(bindings, event, state);\n\n    /* Determine the deepest path index to emit the event\n     from, to avoid duplicate events being fired. */\n\n    const path = util.getPropagationPath(event);\n    gestures.forEach((gesture) => {\n      const id = gesture.binding.gesture.getId();\n      if (toBeDispatched[id]) {\n        if (util.getPathIndex(path, gesture.binding.element) <\n          util.getPathIndex(path, toBeDispatched[id].binding.element)) {\n          toBeDispatched[id] = gesture;\n        }\n      } else {\n        toBeDispatched[id] = gesture;\n      }\n    });\n\n    Object.keys(toBeDispatched).forEach((index) => {\n      const gesture = toBeDispatched[index];\n      dispatcher(gesture.binding, gesture.data, gesture.events);\n    });\n  }\n\n  let endCount = 0;\n  state.inputs.forEach((input) => {\n    if (input.getCurrentEventType() === 'end') {\n      endCount++;\n    }\n  });\n\n  if (endCount === state.inputs.length) {\n    state.resetInputs();\n  }\n}\n\nexport default arbiter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/arbiter.js","/**\n * @file dispatcher.js\n * Contains logic for the dispatcher\n */\n\n/**\n * Emits data at the target element if available, and bubbles up from\n * the target to the parent until the document has been reached.\n * Called from the arbiter.\n * @param {Binding} binding - An object of type Binding\n * @param {Object} data - The metadata computed by the gesture being emitted.\n * @param {Array} events - An array of ZingEvents\n *  corresponding to the inputs on the screen.\n */\nfunction dispatcher(binding, data, events) {\n  data.events = events;\n\n  const newEvent = new CustomEvent(binding.gesture.getId(), {\n    detail: data,\n    bubbles: true,\n    cancelable: true,\n  });\n  emitEvent(binding.element, newEvent, binding);\n}\n\n/**\n * Emits the new event. Unbinds the event if the event was registered\n * at bindOnce.\n * @param {Element} target - Element object to emit the event to.\n * @param {Event} event - The CustomEvent to emit.\n * @param {Binding} binding - An object of type Binding\n */\nfunction emitEvent(target, event, binding) {\n  target.dispatchEvent(event);\n  if (binding.bindOnce) {\n    ZingTouch.unbind(binding.element, binding.gesture.getType());\n  }\n}\n\nexport default dispatcher;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/dispatcher.js","/**\n * @file interpreter.js\n * Contains logic for the interpreter\n */\n\nimport util from './util.js';\n\n/**\n * Receives an event and an array of Bindings (element -> gesture handler)\n * to determine what event will be emitted. Called from the arbiter.\n * @param {Array} bindings - An array containing Binding objects\n * that associate the element to an event handler.\n * @param {Object} event - The event emitted from the window.\n * @param {Object} state - The state object of the current listener.\n * @return {Object | null} - Returns an object containing a binding and\n * metadata, or null if a gesture will not be emitted.\n */\nfunction interpreter(bindings, event, state) {\n  const evType = util.normalizeEvent[ event.type ];\n  const events = state.inputs.map( input => input.current );\n\n  const candidates = bindings.reduce( (accumulator, binding) => {\n    const data = binding.gesture[evType](state.inputs, state, binding.element);\n    if (data) accumulator.push({ binding, data, events });\n    return accumulator;\n  }, []);\n\n  return candidates;\n}\n\nexport default interpreter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/interpreter.js","/**\n * @file State.js\n */\n\nimport Gesture from './../../gestures/Gesture.js';\nimport Pan from './../../gestures/Pan.js';\nimport Pinch from './../../gestures/Pinch.js';\nimport Rotate from './../../gestures/Rotate.js';\nimport Swipe from './../../gestures/Swipe.js';\nimport Tap from './../../gestures/Tap.js';\nimport Binding from './Binding.js';\nimport Input from './Input.js';\nimport util from './../util.js';\n\nconst DEFAULT_MOUSE_ID = 0;\n\n/**\n * Creates an object related to a Region's state,\n * and contains helper methods to update and clean up different states.\n */\nclass State {\n\n  /**\n   * Constructor for the State class.\n   * @param {String} regionId - The id the region this state is bound to.\n   */\n  constructor(regionId) {\n    /**\n     * The id for the region this state is bound to.\n     * @type {String}\n     */\n    this.regionId = regionId;\n\n    /**\n     * An array of current and recently inactive\n     *  Input objects related to a gesture.\n     * @type {Input}\n     */\n    this.inputs = [];\n\n    /**\n     * An array of Binding objects; The list of relations between elements,\n     *   their gestures, and the handlers.\n     * @type {Binding}\n     */\n    this.bindings = [];\n\n    /**\n     * The number of gestures that have been registered with this state\n     * @type {Number}\n     */\n    this.numGestures = 0;\n\n    /**\n     * A key/value map all the registered gestures for the listener.\n     *  Note: Can only have one gesture registered to one key.\n     * @type {Object}\n     */\n    this.registeredGestures = {};\n\n    this.registerGesture(new Pan(), 'pan');\n    this.registerGesture(new Rotate(), 'rotate');\n    this.registerGesture(new Pinch(), 'pinch');\n    this.registerGesture(new Swipe(), 'swipe');\n    this.registerGesture(new Tap(), 'tap');\n  }\n\n  /**\n   * Creates a new binding with the given element and gesture object.\n   * If the gesture object provided is unregistered, it's reference\n   * will be saved in as a binding to be later referenced.\n   * @param  {Element} element - The element the gesture is bound to.\n   * @param {String|Object} gesture  - Either a name of a registered gesture,\n   *  or an unregistered  Gesture object.\n   * @param {Function} handler - The function handler to be called\n   *  when the event is emitted. Used to bind/unbind.\n   * @param {Boolean} capture - Whether the gesture is to be\n   *  detected in the capture of bubble phase. Used to bind/unbind.\n   * @param {Boolean} bindOnce - Option to bind once and\n   *  only emit the event once.\n   */\n  addBinding(element, gesture, handler, capture, bindOnce) {\n    let boundGesture;\n\n    // Error type checking.\n    if (element && typeof element.tagName === 'undefined') {\n      throw new Error('Parameter element is an invalid object.');\n    }\n\n    if (typeof handler !== 'function') {\n      throw new Error('Parameter handler is invalid.');\n    }\n\n    if (typeof gesture === 'string' &&\n      Object.keys(this.registeredGestures).indexOf(gesture) === -1) {\n      throw new Error('Parameter ' + gesture + ' is not a registered gesture');\n    } else if (typeof gesture === 'object' && !(gesture instanceof Gesture)) {\n      throw new Error('Parameter for the gesture is not of a Gesture type');\n    }\n\n    if (typeof gesture === 'string') {\n      boundGesture = this.registeredGestures[gesture];\n    } else {\n      boundGesture = gesture;\n      if (boundGesture.id === '') {\n        this.assignGestureId(boundGesture);\n      }\n    }\n\n    this.bindings.push(new Binding(element, boundGesture,\n      handler, capture, bindOnce));\n    element.addEventListener(boundGesture.getId(), handler, capture);\n  }\n\n  /**\n   * Retrieves the Binding by which an element is associated to.\n   * @param {Element} element - The element to find bindings to.\n   * @return {Array} - An array of Bindings to which that element is bound\n   */\n  retrieveBindingsByElement(element) {\n    return this.bindings.filter( b => b.element === element );\n  }\n\n  /**\n   * Retrieves all bindings based upon the initial X/Y position of the inputs.\n   * e.g. if gesture started on the correct target element,\n   *  but diverted away into the correct region, this would still be valid.\n   * @return {Array} - An array of Bindings to which that element is bound\n   */\n  retrieveBindingsByInitialPos() {\n    return this.bindings.filter( binding => {\n      return this.inputs.some( input => {\n        return util.isInside(input.initial.x, input.initial.y, binding.element);\n      });\n    });\n  }\n\n  /**\n   * Updates the inputs with new information based upon a new event being fired.\n   * @param {Event} event - The event being captured.\n   * @param {Element} regionElement - The element where\n   *  this current Region is bound to.\n   * @return {boolean} - returns true for a successful update,\n   *  false if the event is invalid.\n   */\n  updateInputs(event, regionElement) {\n    let eventType = (event.touches) ?\n      'TouchEvent' : ((event.pointerType) ? 'PointerEvent' : 'MouseEvent');\n    switch (eventType) {\n      case 'TouchEvent':\n        Array.from(event.changedTouches).forEach( touch => {\n          update(event, this, touch.identifier, regionElement);\n        });\n        break;\n\n      case 'PointerEvent':\n        update(event, this, event.pointerId, regionElement);\n        break;\n\n      case 'MouseEvent':\n      default:\n        update(event, this, DEFAULT_MOUSE_ID, regionElement);\n        break;\n    }\n    return true;\n\n    function update(event, state, identifier, regionElement) {\n      const eventType = util.normalizeEvent[ event.type ];\n      const input = findInputById(state.inputs, identifier);\n\n      // A starting input was not cleaned up properly and still exists.\n      if (eventType === 'start' && input) {\n        state.resetInputs();\n        return;\n      }\n\n      // An input has moved outside the region.\n      if (eventType !== 'start' &&\n        input &&\n        !util.isInside(input.current.x, input.current.y, regionElement)) {\n         state.resetInputs();\n        return;\n      }\n\n      if (eventType !== 'start' && !input) {\n        state.resetInputs();\n        return;\n      }\n\n      if (eventType === 'start') {\n        state.inputs.push(new Input(event, identifier));\n      } else {\n        input.update(event, identifier);\n      }\n    }\n  }\n\n  /**\n   * Removes all inputs from the state, allowing for a new gesture.\n   */\n  resetInputs() {\n    this.inputs = [];\n  }\n\n  /**\n   * Counts the number of active inputs at any given time.\n   * @return {Number} - The number of active inputs.\n   */\n  numActiveInputs() {\n    const endType = this.inputs.filter((input) => {\n      return input.current.type !== 'end';\n    });\n    return endType.length;\n  }\n\n  /**\n   * Register the gesture to the current region.\n   * @param {Object} gesture - The gesture to register\n   * @param {String} key - The key to define the new gesture as.\n   */\n  registerGesture(gesture, key) {\n    this.assignGestureId(gesture);\n    this.registeredGestures[key] = gesture;\n  }\n\n  /**\n   * Tracks the gesture to this state object to become uniquely identifiable.\n   * Useful for nested Regions.\n   * @param {Gesture} gesture - The gesture to track\n   */\n  assignGestureId(gesture) {\n    gesture.setId(this.regionId + '-' + this.numGestures++);\n  }\n\n}\n/**\n * Searches through each input, comparing the browser's identifier key\n *  for touches, to the stored one in each input\n * @param {Array} inputs - The array of inputs in state.\n * @param {String} identifier - The identifier the browser has assigned.\n * @return {Input} - The input object with the corresponding identifier,\n *  null if it did not find any.\n */\nfunction findInputById(inputs, identifier) {\n  return inputs.find( i => i.identifier === identifier );\n}\n\nexport default State;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/State.js","/**\n * @file Pan.js\n * Contains the Pan class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MIN_THRESHOLD = 1;\n\n/**\n * A Pan is defined as a normal movement in any direction on a screen.\n * Pan gestures do not track start events and can interact with pinch and \\\n *  expand gestures.\n * @class Pan\n */\nclass Pan extends Gesture {\n  /**\n   * Constructor function for the Pan class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.numInputs=1] - Number of inputs for the\n   *  Pan gesture.\n   * @param {Number} [options.threshold=1] - The minimum number of\n   * pixels the input has to move to trigger this gesture.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'pan';\n\n    /**\n     * The number of inputs to trigger a Pan can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * The minimum amount in pixels the pan must move until it is fired.\n     * @type {Number}\n     */\n    this.threshold = (options && options.threshold) ?\n      options.threshold : DEFAULT_MIN_THRESHOLD;\n  }\n\n  /**\n   * Event hook for the start of a gesture. Marks each input as active,\n   * so it can invalidate any end events.\n   * @param {Array} inputs\n   */\n  start(inputs) {\n    inputs.forEach((input) => {\n      const progress = input.getGestureProgress(this.getId());\n      progress.active = true;\n      progress.lastEmitted = {\n        x: input.current.x,\n        y: input.current.y,\n      };\n    });\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture.\n   * Fired whenever the input length is met, and keeps a boolean flag that\n   * the gesture has fired at least once.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {Object} - Returns the distance in pixels between the two inputs.\n   */\n  move(inputs, state, element) {\n    if (this.numInputs !== inputs.length) return null;\n\n    const output = {\n      data: [],\n    };\n\n    inputs.forEach( (input, index) => {\n      const progress = input.getGestureProgress(this.getId());\n      const distanceFromLastEmit = util.distanceBetweenTwoPoints(\n        progress.lastEmitted.x,\n        progress.lastEmitted.y,\n        input.current.x,\n        input.current.y\n      );\n      const reachedThreshold = distanceFromLastEmit >= this.threshold;\n\n      if (progress.active && reachedThreshold) {\n        output.data[index] = packData( input, progress );\n        progress.lastEmitted.x = input.current.x;\n        progress.lastEmitted.y = input.current.y;\n      } \n    });\n\n    return output;\n\n    function packData( input, progress ) {\n      const distanceFromOrigin = util.distanceBetweenTwoPoints(\n        input.initial.x,\n        input.current.x,\n        input.initial.y,\n        input.current.y\n      );\n      const directionFromOrigin = util.getAngle(\n        input.initial.x,\n        input.initial.y,\n        input.current.x,\n        input.current.y\n      );\n      const currentDirection = util.getAngle(\n        progress.lastEmitted.x,\n        progress.lastEmitted.y,\n        input.current.x,\n        input.current.y\n      );\n      const change = {\n        x: input.current.x - progress.lastEmitted.x,\n        y: input.current.y - progress.lastEmitted.y,\n      };\n\n      return {\n        distanceFromOrigin,\n        directionFromOrigin,\n        currentDirection,\n        change,\n      };\n    }\n  }\n\n  /* move*/\n\n  /**\n   * end() - Event hook for the end of a gesture. If the gesture has at least\n   * fired once, then it ends on the first end event such that any remaining\n   * inputs will not trigger the event until all inputs have reached the\n   * touchend event. Any touchend->touchstart events that occur before all\n   * inputs are fully off the screen should not fire.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null} - null if the gesture is not to be emitted,\n   *  Object with information otherwise.\n   */\n  end(inputs) {\n    inputs.forEach((input) => {\n      const progress = input.getGestureProgress(this.getId());\n      progress.active = false;\n    });\n    return null;\n  }\n\n  /* end*/\n}\n\nexport default Pan;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Pan.js","/**\n * @file Pinch.js\n * Contains the abstract Pinch class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 2;\nconst DEFAULT_MIN_THRESHOLD = 1;\n\n/**\n * A Pinch is defined as two inputs moving either together or apart.\n * @class Pinch\n */\nclass Pinch extends Gesture {\n  /**\n   * Constructor function for the Pinch class.\n   * @param {Object} options\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'pinch';\n\n    /**\n     * The minimum amount in pixels the inputs must move until it is fired.\n     * @type {Number}\n     */\n    this.threshold = (options && options.threshold) ?\n      options.threshold : DEFAULT_MIN_THRESHOLD;\n  }\n\n  /**\n   * Event hook for the start of a gesture. Initialized the lastEmitted\n   * gesture and stores it in the first input for reference events.\n   * @param {Array} inputs\n   */\n  start(inputs, state, element) {\n    if(!this.isValid(inputs, state, element)) {\n      return null;\n    }\n    if (inputs.length === DEFAULT_INPUTS) {\n      // Store the progress in the first input.\n      const progress = inputs[0].getGestureProgress(this.type);\n      progress.lastEmittedDistance = util.distanceBetweenTwoPoints(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n    }\n  }\n\n  /**\n   * Event hook for the move of a gesture.\n   *  Determines if the two points are moved in the expected direction relative\n   *  to the current distance and the last distance.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {Object | null} - Returns the distance in pixels between two inputs\n   */\n  move(inputs, state, element) {\n    if (state.numActiveInputs() === DEFAULT_INPUTS) {\n      const currentDistance = util.distanceBetweenTwoPoints(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n      const centerPoint = util.getMidpoint(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n\n      // Progress is stored in the first input.\n      const progress = inputs[0].getGestureProgress(this.type);\n      const change = currentDistance - progress.lastEmittedDistance;\n\n      if (Math.abs(change) >= this.threshold) {\n        progress.lastEmittedDistance = currentDistance;\n        return {\n          distance: currentDistance,\n          center: centerPoint,\n          change: change,\n        };\n      }\n    }\n\n    return null;\n  }\n}\n\nexport default Pinch;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Pinch.js","/**\n * @file Rotate.js\n * Contains the Rotate class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 2;\n\n/**\n * A Rotate is defined as two inputs moving about a circle,\n * maintaining a relatively equal radius.\n * @class Rotate\n */\nclass Rotate extends Gesture {\n  /**\n   * Constructor function for the Rotate class.\n   */\n  constructor(options = {}) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'rotate';\n\n    /**\n     * The number of touches required to emit Rotate events.\n     * @type {Number}\n     */\n    this.numInputs = options.numInputs || DEFAULT_INPUTS;\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture. Obtains the midpoint of two\n   * the two inputs and calculates the projection of the right most input along\n   * a unit circle to obtain an angle. This angle is compared to the previously\n   * calculated angle to output the change of distance, and is compared to the\n   * initial angle to output the distance from the initial angle to the current\n   * angle.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current listener.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - null if this event did not occur\n   * @return {Object} obj.angle - The current angle along the unit circle\n   * @return {Object} obj.distanceFromOrigin - The angular distance travelled\n   * from the initial right most point.\n   * @return {Object} obj.distanceFromLast - The change of angle between the\n   * last position and the current position.\n   */\n  move(inputs, state, element) {\n    const numActiveInputs = state.numActiveInputs();\n    if (this.numInputs !== numActiveInputs) return null;\n\n    let currentPivot, initialPivot;\n    let input;\n    if (numActiveInputs === 1) {\n      const bRect = element.getBoundingClientRect();\n      currentPivot = {\n        x: bRect.left + bRect.width / 2,\n        y: bRect.top + bRect.height / 2,\n      };\n      initialPivot = currentPivot;\n      input = inputs[0];\n    } else {\n      currentPivot = util.getMidpoint(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n      input = util.getRightMostInput(inputs);\n    }\n\n    // Translate the current pivot point.\n    const currentAngle = util.getAngle(\n      currentPivot.x, \n      currentPivot.y,\n      input.current.x,\n      input.current.y);\n\n    const progress = input.getGestureProgress(this.getId());\n    if (!progress.initialAngle) {\n      progress.initialAngle = progress.previousAngle = currentAngle;\n      progress.distance = progress.change = 0;\n    } else {\n      progress.change = util.getAngularDistance(\n        progress.previousAngle,\n        currentAngle);\n      progress.distance = progress.distance + progress.change;\n    }\n\n    progress.previousAngle = currentAngle;\n\n    return {\n      angle: currentAngle,\n      distanceFromOrigin: progress.distance,\n      distanceFromLast: progress.change,\n    };\n  }\n\n  /* move*/\n}\n\nexport default Rotate;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Rotate.js","/**\n * @file Swipe.js\n * Contains the Swipe class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MAX_REST_TIME = 100;\nconst DEFAULT_ESCAPE_VELOCITY = 0.2;\nconst DEFAULT_TIME_DISTORTION = 100;\nconst DEFAULT_MAX_PROGRESS_STACK = 10;\n\n/**\n * A swipe is defined as input(s) moving in the same direction in an relatively\n * increasing velocity and leaving the screen at some point before it drops\n * below it's escape velocity.\n * @class Swipe\n */\nclass Swipe extends Gesture {\n\n  /**\n   * Constructor function for the Swipe class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.numInputs] - The number of inputs to trigger a\n   * Swipe can be variable, and the maximum number being a factor of the browser\n   *  move and current move events.\n   * @param {Number} [options.maxRestTime] - The maximum resting time a point\n   *  has between it's last\n   * @param {Number} [options.escapeVelocity] - The minimum velocity the input\n   *  has to be at to emit a swipe.\n   * @param {Number} [options.timeDistortion] - (EXPERIMENTAL) A value of time\n   *  in milliseconds to distort between events.\n   * @param {Number} [options.maxProgressStack] - (EXPERIMENTAL)The maximum\n   *  amount of move events to keep\n   * track of for a swipe.\n   */\n  constructor(options) {\n    super();\n    /**\n     * The type of the Gesture\n     * @type {String}\n     */\n    this.type = 'swipe';\n\n    /**\n     * The number of inputs to trigger a Swipe can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * The maximum resting time a point has between it's last move and\n     * current move events.\n     * @type {Number}\n     */\n    this.maxRestTime = (options && options.maxRestTime) ?\n      options.maxRestTime : DEFAULT_MAX_REST_TIME;\n\n    /**\n     * The minimum velocity the input has to be at to emit a swipe.\n     * This is useful for determining the difference between\n     * a swipe and a pan gesture.\n     * @type {number}\n     */\n    this.escapeVelocity = (options && options.escapeVelocity) ?\n      options.escapeVelocity : DEFAULT_ESCAPE_VELOCITY;\n\n    /**\n     * (EXPERIMENTAL) A value of time in milliseconds to distort between events.\n     * Browsers do not accurately measure time with the Date constructor in\n     * milliseconds, so consecutive events sometimes display the same timestamp\n     * but different x/y coordinates. This will distort a previous time\n     * in such cases by the timeDistortion's value.\n     * @type {number}\n     */\n    this.timeDistortion = (options && options.timeDistortion) ?\n      options.timeDistortion : DEFAULT_TIME_DISTORTION;\n\n    /**\n     * (EXPERIMENTAL) The maximum amount of move events to keep track of for a\n     * swipe. This helps give a more accurate estimate of the user's velocity.\n     * @type {number}\n     */\n    this.maxProgressStack = (options && options.maxProgressStack) ?\n      options.maxProgressStack : DEFAULT_MAX_PROGRESS_STACK;\n  }\n\n  /**\n   * Event hook for the move of a gesture. Captures an input's x/y coordinates\n   * and the time of it's event on a stack.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - Swipe does not emit from a move.\n   */\n  move(inputs, state, element) {\n    if (this.numInputs === inputs.length) {\n      for (let i = 0; i < inputs.length; i++) {\n        let progress = inputs[i].getGestureProgress(this.getId());\n        if (!progress.moves) {\n          progress.moves = [];\n        }\n\n        progress.moves.push({\n          time: new Date().getTime(),\n          x: inputs[i].current.x,\n          y: inputs[i].current.y,\n        });\n\n        if (progress.length > this.maxProgressStack) {\n          progress.moves.shift();\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /* move*/\n\n  /**\n   * Determines if the input's history validates a swipe motion.\n   * Determines if it did not come to a complete stop (maxRestTime), and if it\n   * had enough of a velocity to be considered (ESCAPE_VELOCITY).\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null|Object} - null if the gesture is not to be emitted,\n   *  Object with information otherwise.\n   */\n  end(inputs) {\n    if (this.numInputs === inputs.length) {\n      let output = {\n        data: [],\n      };\n\n      for (var i = 0; i < inputs.length; i++) {\n        // Determine if all input events are on the 'end' event.\n        if (inputs[i].current.type !== 'end') {\n          return;\n        }\n\n        let progress = inputs[i].getGestureProgress(this.getId());\n        if (progress.moves && progress.moves.length > 2) {\n          // CHECK : Return if the input has not moved in maxRestTime ms.\n\n          let currentMove = progress.moves.pop();\n          if ((new Date().getTime()) - currentMove.time > this.maxRestTime) {\n            return null;\n          }\n\n          let lastMove;\n          let index = progress.moves.length - 1;\n\n          /* Date is unreliable, so we retrieve the last move event where\n           the time is not the same. */\n          while (index !== -1) {\n            if (progress.moves[index].time !== currentMove.time) {\n              lastMove = progress.moves[index];\n              break;\n            }\n\n            index--;\n          }\n\n          /* If the date is REALLY unreliable, we apply a time distortion\n           to the last event.\n           */\n          if (!lastMove) {\n            lastMove = progress.moves.pop();\n            lastMove.time += this.timeDistortion;\n          }\n\n          var velocity = util.getVelocity(lastMove.x, lastMove.y, lastMove.time,\n            currentMove.x, currentMove.y, currentMove.time);\n\n          output.data[i] = {\n            velocity: velocity,\n            distance: util.distanceBetweenTwoPoints(lastMove.x, currentMove.x, lastMove.y, currentMove.y),\n            duration:  currentMove.time - lastMove.time,\n            currentDirection: util.getAngle(\n              lastMove.x,\n              lastMove.y,\n              currentMove.x,\n              currentMove.y),\n          };\n        }\n      }\n\n      for (var i = 0; i < output.data.length; i++) {\n        if (velocity < this.escapeVelocity) {\n          return null;\n        }\n      }\n\n      if (output.data.length > 0) {\n        return output;\n      }\n    }\n\n    return null;\n  }\n\n  /* end*/\n}\n\nexport default Swipe;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Swipe.js","/**\n * @file Tap.js\n * Contains the Tap class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_MIN_DELAY_MS = 0;\nconst DEFAULT_MAX_DELAY_MS = 300;\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MOVE_PX_TOLERANCE = 10;\n\n/**\n * A Tap is defined as a touchstart to touchend event in quick succession.\n * @class Tap\n */\nclass Tap extends Gesture {\n  /**\n   * Constructor function for the Tap class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.minDelay=0] - The minimum delay between a\n   * touchstart and touchend can be configured in milliseconds.\n   * @param {Number} [options.maxDelay=300] - The maximum delay between a\n   * touchstart and touchend can be configured in milliseconds.\n   * @param {Number} [options.numInputs=1] - Number of inputs for Tap gesture.\n   * @param {Number} [options.tolerance=10] - The tolerance in pixels\n   *  a user can move.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'tap';\n\n    /**\n     * The minimum amount between a touchstart and a touchend can be configured\n     * in milliseconds. The minimum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     * @type {Number}\n     */\n    this.minDelay = (options && options.minDelay) ?\n      options.minDelay : DEFAULT_MIN_DELAY_MS;\n\n    /**\n     * The maximum delay between a touchstart and touchend can be configured in\n     * milliseconds. The maximum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     * @type {Number}\n     */\n    this.maxDelay = (options && options.maxDelay) ?\n      options.maxDelay : DEFAULT_MAX_DELAY_MS;\n\n    /**\n     * The number of inputs to trigger a Tap can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * A move tolerance in pixels allows some slop between a user's start to end\n     * events. This allows the Tap gesture to be triggered more easily.\n     * @type {number}\n     */\n    this.tolerance = (options && options.tolerance) ?\n      options.tolerance : DEFAULT_MOVE_PX_TOLERANCE;\n  }\n\n  /* constructor*/\n\n  /**\n   * Event hook for the start of a gesture. Keeps track of when the inputs\n   * trigger the start event.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @return {null} - Tap does not trigger on a start event.\n   */\n  start(inputs) {\n    if (inputs.length === this.numInputs) {\n      inputs.forEach((input) => {\n        let progress = input.getGestureProgress(this.type);\n        progress.start = new Date().getTime();\n      });\n    }\n\n    return null;\n  }\n\n  /* start*/\n\n  /**\n   * Event hook for the move of a gesture. The Tap event reaches here if the\n   * user starts to move their input before an 'end' event is reached.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - Tap does not trigger on a move event.\n   */\n  move(inputs, state, element) {\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getCurrentEventType() === 'move') {\n        let current = inputs[i].current;\n        let previous = inputs[i].previous;\n        if (!util.isWithin(\n            current.x,\n            current.y,\n            previous.x,\n            previous.y,\n            this.tolerance)) {\n          let type = this.type;\n          inputs.forEach(function(input) {\n            input.resetProgress(type);\n          });\n\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /* move*/\n\n  /**\n   * Event hook for the end of a gesture.\n   * Determines if this the tap event can be fired if the delay and tolerance\n   * constraints are met. Also waits for all of the inputs to be off the screen\n   * before determining if the gesture is triggered.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @return {null|Object} - null if the gesture is not to be emitted,\n   * Object with information otherwise. Returns the interval time between start\n   * and end events.\n   */\n  end(inputs) {\n    if (inputs.length !== this.numInputs) {\n      return null;\n    }\n\n    let startTime = Number.MAX_VALUE;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getCurrentEventType() !== 'end') {\n        return null;\n      }\n\n      let progress = inputs[i].getGestureProgress(this.type);\n      if (!progress.start) {\n        return null;\n      }\n\n      // Find the most recent input's startTime\n      if (progress.start < startTime) {\n        startTime = progress.start;\n      }\n    }\n\n    let interval = new Date().getTime() - startTime;\n    if ((this.minDelay <= interval) && (this.maxDelay >= interval)) {\n      return {\n        interval: interval,\n      };\n    } else {\n      let type = this.type;\n      inputs.forEach(function(input) {\n        input.resetProgress(type);\n      });\n\n      return null;\n    }\n  }\n\n  /* end*/\n}\n\nexport default Tap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Tap.js","/**\n * @file Binding.js\n */\n\n/**\n * Responsible for creating a binding between an element and a gesture.\n * @class Binding\n */\nclass Binding {\n  /**\n   * Constructor function for the Binding class.\n   * @param {Element} element - The element to associate the gesture to.\n   * @param {Gesture} gesture - A instance of the Gesture type.\n   * @param {Function} handler - The function handler to execute when a\n   * gesture is recognized\n   * on the associated element.\n   * @param {Boolean} [capture=false] - A boolean signifying if the event is\n   * to be emitted during\n   * the capture or bubble phase.\n   * @param {Boolean} [bindOnce=false] - A boolean flag\n   * used for the bindOnce syntax.\n   */\n  constructor(element, gesture, handler, capture, bindOnce) {\n    /**\n     * The element to associate the gesture to.\n     * @type {Element}\n     */\n    this.element = element;\n    /**\n     * A instance of the Gesture type.\n     * @type {Gesture}\n     */\n    this.gesture = gesture;\n    /**\n     * The function handler to execute when a gesture is\n     * recognized on the associated element.\n     * @type {Function}\n     */\n    this.handler = handler;\n\n    /**\n     * A boolean signifying if the event is to be\n     * emitted during the capture or bubble phase.\n     * @type {Boolean}\n     */\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\n\n    /**\n     * A boolean flag used for the bindOnce syntax.\n     * @type {Boolean}\n     */\n    this.bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\n  }\n\n}\n\nexport default Binding;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Binding.js","/**\n * @file Input.js\n */\n\nimport ZingEvent from './ZingEvent.js';\n\n/**\n * Tracks a single input and contains information about the\n * current, previous, and initial events.\n * Contains the progress of each Input and it's associated gestures.\n * @class Input\n */\nclass Input {\n\n  /**\n   * Constructor function for the Input class.\n   * @param {Event} event - The Event object from the window\n   * @param {Number} [identifier=0] - The identifier for each input event\n   * (taken from event.changedTouches)\n   */\n  constructor(event, identifier) {\n    let currentEvent = new ZingEvent(event, identifier);\n\n    /**\n     * Holds the initial event object. A touchstart/mousedown event.\n     * @type {ZingEvent}\n     */\n    this.initial = currentEvent;\n\n    /**\n     * Holds the most current event for this Input, disregarding any other past,\n     * current, and future events that other Inputs participate in.\n     * e.g. This event ended in an 'end' event, but another Input is still\n     * participating in events -- this will not be updated in such cases.\n     * @type {ZingEvent}\n     */\n    this.current = currentEvent;\n\n    /**\n     * Holds the previous event that took place.\n     * @type {ZingEvent}\n     */\n    this.previous = currentEvent;\n\n    /**\n     * Refers to the event.touches index, or 0 if a simple mouse event occurred.\n     * @type {Number}\n     */\n    this.identifier = (typeof identifier !== 'undefined') ? identifier : 0;\n\n    /**\n     * Stores internal state between events for\n     * each gesture based off of the gesture's id.\n     * @type {Object}\n     */\n    this.progress = {};\n  }\n\n  /**\n   * Receives an input, updates the internal state of what the input has done.\n   * @param {Event} event - The event object to wrap with a ZingEvent.\n   * @param {Number} touchIdentifier - The index of inputs, from event.touches\n   */\n  update(event, touchIdentifier) {\n    this.previous = this.current;\n    this.current = new ZingEvent(event, touchIdentifier);\n  }\n\n  /**\n   * Returns the progress of the specified gesture.\n   * @param {String} id - The identifier for each unique Gesture's progress.\n   * @return {Object} - The progress of the gesture.\n   * Creates an empty object if no progress has begun.\n   */\n  getGestureProgress(id) {\n    if (!this.progress[id]) {\n      this.progress[id] = {};\n    }\n    return this.progress[id];\n  }\n\n  /**\n   * Returns the normalized current Event's type.\n   * @return {String} The current event's type ( start | move | end )\n   */\n  getCurrentEventType() {\n    return this.current.type;\n  }\n\n  /**\n   * Resets a progress/state object of the specified gesture.\n   * @param {String} id - The identifier of the specified gesture\n   */\n  resetProgress(id) {\n    this.progress[id] = {};\n  }\n\n}\n\nexport default Input;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Input.js","/**\n * @file ZingEvent.js\n * Contains logic for ZingEvents\n */\n\nimport util from '../util.js';\n\nconst INITIAL_COORDINATE = 0;\n/**\n * An event wrapper that normalizes events across browsers and input devices\n * @class ZingEvent\n */\nclass ZingEvent {\n  /**\n   * @constructor\n   * @param {Event} event - The event object being wrapped.\n   * @param {Array} event.touches - The number of touches on\n   *  a screen (mobile only).\n   * @param {Object} event.changedTouches - The TouchList representing\n   * points that participated in the event.\n   * @param {Number} touchIdentifier - The index of touch if applicable\n   */\n  constructor(event, touchIdentifier) {\n    /**\n     * The original event object.\n     * @type {Event}\n     */\n    this.originalEvent = event;\n\n    /**\n     * The type of event or null if it is an event not predetermined.\n     * @see util.normalizeEvent\n     * @type {String | null}\n     */\n    this.type = util.normalizeEvent[ event.type ];\n\n    /**\n     * The X coordinate for the event, based off of the client.\n     * @type {number}\n     */\n    this.x = INITIAL_COORDINATE;\n\n    /**\n     * The Y coordinate for the event, based off of the client.\n     * @type {number}\n     */\n    this.y = INITIAL_COORDINATE;\n\n    let eventObj;\n    if (event.touches && event.changedTouches) {\n      eventObj = Array.from(event.changedTouches).find( t => {\n        return t.identifier === touchIdentifier;\n      });\n    } else {\n      eventObj = event;\n    }\n\n    this.x = this.clientX = eventObj.clientX;\n    this.y = this.clientY = eventObj.clientY;\n\n    this.pageX = eventObj.pageX;\n    this.pageY = eventObj.pageY;\n\n    this.screenX = eventObj.screenX;\n    this.screenY = eventObj.screenY;\n  }\n}\n\nexport default ZingEvent;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/ZingEvent.js"],"sourceRoot":""}