{"version":3,"sources":["node_modules/westures-core/src/Gesture.js","node_modules/westures-core/src/Point2D.js","node_modules/westures-core/src/constants.js","node_modules/westures-core/src/PointerData.js","node_modules/westures-core/src/Input.js","node_modules/westures-core/src/State.js","node_modules/westures-core/src/utils.js","node_modules/westures-core/src/Region.js","node_modules/westures-core/src/Smoothable.js","node_modules/westures-core/index.js","src/Pan.js","src/Pinch.js","src/Press.js","src/Pull.js","src/angularMinus.js","src/Rotate.js","src/Swipe.js","src/Swivel.js","src/Tap.js","src/Track.js","index.js"],"names":["require","Gesture","Point2D","Smoothable","Pan","element","handler","options","settings","DEFAULTS","previous","identity","outgoing","average","a","b","centroid","state","restart","translation","minus","next","Object","freeze","minInputs","smoothing","module","exports","Pinch","averageDistanceTo","activePoints","distance","scale","Press","delay","tolerance","initial","timeout","setTimeout","recognize","inputs","points","active","slice","map","i","current","point","distanceTo","type","length","clearTimeout","Pull","deadzoneRadius","pivotCenter","pivot","rect","getBoundingClientRect","left","width","top","height","returnValue","output","calculateOutput","PI2","Math","PI","angularMinus","diff","Rotate","previousAngles","angle","stagedAngles","forEach","input","idx","currentAngle","angleTo","getAngle","rotation","PROGRESS_STACK_SIZE","MS_THRESHOLD","calc_angle","moves","vlim","sin","cos","atan2","velocity","start","end","time","calc_velocity","max","Swipe","saved","push","Date","now","splice","result","getResult","validate","direction","data","Swivel","Tap","minDelay","maxDelay","numTaps","taps","concat","getInputsInPhase","filter","tdiff","startTime","some","totalDistance","Track","trackStart","phases","includes","trackMove","trackEnd","trackCancel","Region"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["/*\n * Contains the Gesture class\n */\n\n'use strict';\n\nlet g_id = 0;\n\n/**\n * The Gesture class that all gestures inherit from. A custom gesture class will\n * need to override some or all of the four phase \"hooks\": start, move, end, and\n * cancel.\n *\n * @memberof westures-core\n *\n * @param {string} type - The name of the gesture.\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {object} [options] - Generic gesture options\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of\n * keys whicyh will disable the gesture. The gesture will not be recognized if\n * one of these keys is pressed. If not specified or an empty list, the gesture\n * is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n */\nclass Gesture {\n  constructor(type, element, handler, options = {}) {\n    if (typeof type !== 'string') {\n      throw new TypeError('Gestures require a string type / name');\n    }\n\n    /**\n     * The name of the gesture. (e.g. 'pan' or 'tap' or 'pinch').\n     *\n     * @type {string}\n     */\n    this.type = type;\n\n    /**\n     * The unique identifier for each gesture. This allows for distinctions\n     * across instances of Gestures that are created on the fly (e.g.\n     * gesture-tap-1, gesture-tap-2).\n     *\n     * @type {string}\n     */\n    this.id = `gesture-${this.type}-${g_id++}`;\n\n    /**\n     * The element to which to associate the gesture.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * The function handler to execute when the gesture is recognized on the\n     * associated element.\n     *\n     * @type {Function}\n     */\n    this.handler = handler;\n\n    /**\n     * The options settings.\n     *\n     * @type {object}\n     */\n    this.options = { ...Gesture.DEFAULTS, ...options };\n  }\n\n  /**\n   * Determines whether this gesture is enabled.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {boolean} true if enabled, false otherwise.\n   */\n  isEnabled(state) {\n    const count = state.active.length;\n    const event = state.event;\n    const { enableKeys, disableKeys, minInputs, maxInputs } = this.options;\n\n    return (minInputs <= count) && (maxInputs >= count) &&\n      (enableKeys.length === 0 || enableKeys.some(k => event[k])) &&\n      !disableKeys.some(k => event[k]);\n  }\n\n  /**\n   * Event hook for the start phase of a gesture.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  start() {\n    return null;\n  }\n\n  /**\n   * Event hook for the move phase of a gesture.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  move() {\n    return null;\n  }\n\n  /**\n   * Event hook for the end phase of a gesture.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  end() {\n    return null;\n  }\n\n  /**\n   * Event hook for when an input is cancelled.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  cancel() {\n    return null;\n  }\n\n  /**\n   * Evalutes the given gesture hook, and dispatches any data that is produced.\n   *\n   * @private\n   *\n   * @param {string} hook - Must be one of 'start', 'move', 'end', or 'cancel'.\n   * @param {State} state - The current State instance.\n   */\n  evaluateHook(hook, state) {\n    const data = this[hook](state);\n    if (data) {\n      this.handler({\n        centroid: state.centroid,\n        event:    state.event,\n        phase:    hook,\n        type:     this.type,\n        target:   this.element,\n        ...data,\n      });\n    }\n  }\n}\n\nGesture.DEFAULTS = Object.freeze({\n  enableKeys:  [],\n  disableKeys: [],\n  minInputs:   1,\n  maxInputs:   Number.MAX_VALUE,\n});\n\nmodule.exports = Gesture;\n\n","/*\n * Contains the {@link Point2D} class.\n */\n\n'use strict';\n\n/**\n * The Point2D class stores and operates on 2-dimensional points, represented as\n * x and y coordinates.\n *\n * @memberof westures-core\n *\n * @param {number} [ x=0 ] - The x coordinate of the point.\n * @param {number} [ y=0 ] - The y coordinate of the point.\n */\nclass Point2D {\n  constructor(x = 0, y = 0) {\n    /**\n     * The x coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.x = x;\n\n    /**\n     * The y coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.y = y;\n  }\n\n  /**\n   * Calculates the angle between this point and the given point.\n   *\n   * @param {!westures-core.Point2D} point - Projected point for calculating the\n   * angle.\n   *\n   * @return {number} Radians along the unit circle where the projected\n   * point lies.\n   */\n  angleTo(point) {\n    return Math.atan2(point.y - this.y, point.x - this.x);\n  }\n\n  /**\n   * Determine the average distance from this point to the provided array of\n   * points.\n   *\n   * @param {!westures-core.Point2D[]} points - the Point2D objects to calculate\n   *    the average distance to.\n   *\n   * @return {number} The average distance from this point to the provided\n   *    points.\n   */\n  averageDistanceTo(points) {\n    return this.totalDistanceTo(points) / points.length;\n  }\n\n  /**\n   * Clone this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, identical to this point.\n   */\n  clone() {\n    return new Point2D(this.x, this.y);\n  }\n\n  /**\n   * Calculates the distance between two points.\n   *\n   * @param {!westures-core.Point2D} point - Point to which the distance is\n   * calculated.\n   *\n   * @return {number} The distance between the two points, a.k.a. the\n   *    hypoteneuse.\n   */\n  distanceTo(point) {\n    return Math.hypot(point.x - this.x, point.y - this.y);\n  }\n\n  /**\n   * Subtract the given point from this point.\n   *\n   * @param {!westures-core.Point2D} point - Point to subtract from this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the result of (this\n   * - point).\n   */\n  minus(point) {\n    return new Point2D(\n      this.x - point.x,\n      this.y - point.y\n    );\n  }\n\n  /**\n   * Return the summation of this point to the given point.\n   *\n   * @param {!westures-core.Point2D} point - Point to add to this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the addition of the\n   * two points.\n   */\n  plus(point) {\n    return new Point2D(\n      this.x + point.x,\n      this.y + point.y,\n    );\n  }\n\n  /**\n   * Calculates the total distance from this point to an array of points.\n   *\n   * @param {!westures-core.Point2D[]} points - The array of Point2D objects to\n   *    calculate the total distance to.\n   *\n   * @return {number} The total distance from this point to the provided points.\n   */\n  totalDistanceTo(points) {\n    return points.reduce((d, p) => d + this.distanceTo(p), 0);\n  }\n\n  /**\n   * Calculates the centroid of a list of points.\n   *\n   * @param {westures-core.Point2D[]} points - The array of Point2D objects for\n   * which to calculate the centroid.\n   *\n   * @return {westures-core.Point2D} The centroid of the provided points.\n   */\n  static centroid(points = []) {\n    if (points.length === 0) return null;\n\n    const total = Point2D.sum(points);\n    return new Point2D(\n      total.x / points.length,\n      total.y / points.length,\n    );\n  }\n\n  /**\n   * Calculates the sum of the given points.\n   *\n   * @param {westures-core.Point2D[]} points - The Point2D objects to sum up.\n   *\n   * @return {westures-core.Point2D} A new Point2D representing the sum of the\n   * given points.\n   */\n  static sum(points = []) {\n    return points.reduce((total, pt) => total.plus(pt), new Point2D(0, 0));\n  }\n}\n\nmodule.exports = Point2D;\n\n","/*\n * Contains event list definitions, PHASE mapping, and other constants.\n */\n\n'use strict';\n\n/**\n * List of events that trigger the cancel phase.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst CANCEL_EVENTS = Object.freeze([\n  'blur',\n  'pointercancel',\n  'touchcancel',\n]);\n\n/**\n * List of keyboard events that trigger a restart.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst KEYBOARD_EVENTS = Object.freeze([\n  'keydown',\n  'keyup',\n]);\n\n/**\n * List of mouse events to listen to.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst MOUSE_EVENTS = Object.freeze([\n  'mousedown',\n  'mousemove',\n  'mouseup',\n]);\n\n/**\n * List of pointer events to listen to.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst POINTER_EVENTS = Object.freeze([\n  'pointerdown',\n  'pointermove',\n  'pointerup',\n]);\n\n/**\n * List of touch events to listen to.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst TOUCH_EVENTS = Object.freeze([\n  'touchend',\n  'touchmove',\n  'touchstart',\n]);\n\n/**\n * List of potential values for the input source string.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst SOURCE_STRINGS = Object.freeze([\n  'client',\n  'page',\n  'screen',\n]);\n\n/**\n * List of potentially state-modifying keys.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst STATE_KEYS = Object.freeze([\n  'altKey',\n  'ctrlKey',\n  'metaKey',\n  'shiftKey',\n]);\n\n/**\n * List of the 'key' values on KeyboardEvent objects of the potentially\n * state-modifying keys.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst STATE_KEY_STRINGS = Object.freeze([\n  'Alt',\n  'Control',\n  'Meta',\n  'Shift',\n]);\n\n/**\n * The cancel phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst CANCEL = 'cancel';\n\n/**\n * The end phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst END = 'end';\n\n/**\n * The move phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst MOVE = 'move';\n\n/**\n * The start phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst START = 'start';\n\n/**\n * Normalizes window events to be either of type start, move, end, or cancel.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst PHASE = Object.freeze({\n  blur:           CANCEL,\n  pointercancel:  CANCEL,\n  touchcancel:    CANCEL,\n\n  mouseup:       END,\n  pointerup:     END,\n  touchend:      END,\n\n  mousemove:   MOVE,\n  pointermove: MOVE,\n  touchmove:   MOVE,\n\n  mousedown:   START,\n  pointerdown: START,\n  touchstart:  START,\n});\n\nmodule.exports = {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  SOURCE_STRINGS,\n  STATE_KEYS,\n  STATE_KEY_STRINGS,\n\n  CANCEL,\n  END,\n  MOVE,\n  START,\n\n  PHASE,\n};\n\n","/*\n * Contains the {@link PointerData} class\n */\n\n'use strict';\n\nconst Point2D   = require('./Point2D.js');\nconst { PHASE } = require('./constants.js');\n\n/**\n * @private\n * @inner\n * @memberof PointerData\n *\n * @return {Event} The Event object which corresponds to the given identifier.\n *    Contains pageX, pageY values (or whichever X/Y source was selected).\n */\nfunction getEventObject(event, identifier) {\n  if (event.changedTouches) {\n    return Array.from(event.changedTouches).find(touch => {\n      return touch.identifier === identifier;\n    });\n  }\n  return event;\n}\n\n/**\n * Low-level storage of pointer data based on incoming data from an interaction\n * event.\n *\n * @param {Event} event - The event object being wrapped.\n * @param {number} identifier - The index of touch if applicable\n * @param {westures-core.SOURCE_STRINGS} [source='page'] - Determines what the\n * source of (x,y) coordinates will be from the input events. ('X' and 'Y' will\n * be appended, then those are the properties that will be looked up).\n */\nclass PointerData {\n  constructor(event, identifier, source = 'page') {\n    /**\n     * The original event object.\n     *\n     * @type {Event}\n     */\n    this.originalEvent = event;\n\n    /**\n     * The type or 'phase' of this batch of pointer data. 'start' or 'move' or\n     * 'end' or 'cancel'\n     *\n     * @type {string}\n     */\n    this.type = PHASE[event.type];\n\n    /**\n     * The timestamp of the event in milliseconds elapsed since January 1, 1970,\n     * 00:00:00 UTC.\n     *\n     * @type {number}\n     */\n    this.time = Date.now();\n\n    const eventObj = getEventObject(event, identifier);\n    /**\n     * The (x,y) coordinate of the event, wrapped in a Point2D.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.point = new Point2D(eventObj[`${source}X`], eventObj[`${source}Y`]);\n  }\n\n  /**\n   * Calculates the angle between this event and the given event.\n   *\n   * @param {PointerData} pdata\n   *\n   * @return {number} Radians measurement between this event and the given\n   *    event's points.\n   */\n  angleTo(pdata) {\n    return this.point.angleTo(pdata.point);\n  }\n\n  /**\n   * Calculates the distance between two PointerDatas.\n   *\n   * @param {PointerData} pdata\n   *\n   * @return {number} The distance between the two points, a.k.a. the\n   *    hypoteneuse.\n   */\n  distanceTo(pdata) {\n    return this.point.distanceTo(pdata.point);\n  }\n}\n\nmodule.exports = PointerData;\n\n","/*\n * Contains the {@link Input} class\n */\n\n'use strict';\n\nconst PointerData = require('./PointerData.js');\n\n/**\n * In case event.composedPath() is not available.\n *\n * @private\n * @inner\n * @memberof Input\n *\n * @param {Event} event\n *\n * @return {Element[]} The elements along the composed path of the event.\n */\nfunction getPropagationPath(event) {\n  if (typeof event.composedPath === 'function') {\n    return event.composedPath();\n  }\n\n  const path = [];\n  for (let node = event.target; node !== document; node = node.parentNode) {\n    path.push(node);\n  }\n  path.push(document);\n  path.push(window);\n\n  return path;\n}\n\n/**\n * A WeakSet is used so that references will be garbage collected when the\n * element they point to is removed from the page.\n *\n * @private\n * @inner\n * @memberof Input\n * @return {WeakSet.<Element>} The Elements in the path of the given event.\n */\nfunction getElementsInPath(event) {\n  return new WeakSet(getPropagationPath(event));\n}\n\n/**\n * Tracks a single input and contains information about the current, previous,\n * and initial events. Contains the progress of each Input and its associated\n * gestures.\n *\n * @param {(PointerEvent | MouseEvent | TouchEvent)} event - The input event\n * which will initialize this Input object.\n * @param {number} identifier - The identifier for this input, so that it can\n * be located in subsequent Event objects.\n * @param {string} [source='page'] - One of 'page', 'client', or 'screen'.\n * Determines what the source of (x,y) coordinates will be from the input\n * events. ('X' and 'Y' will be appended, then those are the properties that\n * will be looked up).\n */\nclass Input {\n  constructor(event, identifier, source) {\n    const currentData = new PointerData(event, identifier, source);\n\n    /**\n     * Which X/Y attributes of input events to look up for determining input\n     * location.\n     *\n     * @private\n     * @type {string}\n     */\n    this.source = source;\n\n    /**\n     * The set of elements along the original event's propagation path at the\n     * time it was dispatched.\n     *\n     * @private\n     * @type {WeakSet.<Element>}\n     */\n    this.initialElements = getElementsInPath(event);\n\n    /**\n     * Holds the initial data from the mousedown / touchstart / pointerdown that\n     * began this input.\n     *\n     * @type {PointerData}\n     */\n    this.initial = currentData;\n\n    /**\n     * Holds the most current pointer data for this Input.\n     *\n     * @type {PointerData}\n     */\n    this.current = currentData;\n\n    /**\n     * Holds the previous pointer data for this Input.\n     *\n     * @type {PointerData}\n     */\n    this.previous = currentData;\n\n    /**\n     * The identifier for the pointer / touch / mouse button associated with\n     * this input.\n     *\n     * @type {number}\n     */\n    this.identifier = identifier;\n  }\n\n  /**\n   * The phase of the input: 'start' or 'move' or 'end' or 'cancel'\n   *\n   * @type {string}\n   */\n  get phase() { return this.current.type; }\n\n  /**\n   * The timestamp of the initiating event for this input.\n   *\n   * @type {number}\n   */\n  get startTime() { return this.initial.time; }\n\n  /**\n   * @return {number} The distance between the initiating event for this input\n   *    and its current event.\n   */\n  totalDistance() {\n    return this.initial.distanceTo(this.current);\n  }\n\n  /**\n   * Saves the given raw event in PointerData form as the current data for this\n   * input, pushing the old current data into the previous slot, and tossing\n   * out the old previous data.\n   *\n   * @private\n   *\n   * @param {Event} event - The event object to wrap with a PointerData.\n   */\n  update(event) {\n    this.previous = this.current;\n    this.current = new PointerData(event, this.identifier, this.source);\n  }\n\n  /**\n   * Determines if this PointerData was inside the given element at the time it\n   * was dispatched.\n   *\n   * @private\n   *\n   * @param {Element} element\n   *\n   * @return {boolean} true if the Input began inside the element, false\n   *    otherwise.\n   */\n  wasInitiallyInside(element) {\n    return this.initialElements.has(element);\n  }\n}\n\nmodule.exports = Input;\n\n","/*\n * Contains the {@link State} class\n */\n\n'use strict';\n\nconst {\n  CANCEL,\n  END,\n  MOVE,\n  PHASE,\n  START,\n} = require('./constants.js');\nconst Input     = require('./Input.js');\nconst Point2D   = require('./Point2D.js');\n\nconst symbols = Object.freeze({\n  inputs: Symbol.for('inputs'),\n});\n\n/**\n * Set of helper functions for updating inputs based on type of input.\n * Must be called with a bound 'this', via bind(), or call(), or apply().\n *\n * @private\n * @inner\n * @memberof State\n */\nconst update_fns = {\n  TouchEvent: function TouchEvent(event) {\n    Array.from(event.changedTouches).forEach(touch => {\n      this.updateInput(event, touch.identifier);\n    });\n  },\n\n  PointerEvent: function PointerEvent(event) {\n    this.updateInput(event, event.pointerId);\n  },\n\n  MouseEvent: function MouseEvent(event) {\n    if (event.button === 0) {\n      this.updateInput(event, event.button);\n    }\n  },\n};\n\n/**\n * Keeps track of currently active and ending input points on the interactive\n * surface.\n *\n * @param {Element} element - The element underpinning the associated Region.\n * @param {string} [source='page'] - One of 'page', 'client', or 'screen'.\n * Determines what the source of (x,y) coordinates will be from the input\n * events. ('X' and 'Y' will be appended, then those are the properties that\n * will be looked up).\n */\nclass State {\n  constructor(element, source) {\n    /**\n     * Keep a reference to the element for the associated region.\n     *\n     * @private\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Which X/Y attributes of input events to look up for determining input\n     * location.\n     *\n     * @private\n     * @type {string}\n     */\n    this.source = source;\n\n    /**\n     * Keeps track of the current Input objects.\n     *\n     * @private\n     * @alias [@@inputs]\n     * @type {Map.<Input>}\n     * @memberof State\n     */\n    this[symbols.inputs] = new Map();\n\n    /**\n     * All currently valid inputs, including those that have ended.\n     *\n     * @type {Input[]}\n     */\n    this.inputs = [];\n\n    /**\n     * The array of currently active inputs, sourced from the current Input\n     * objects. \"Active\" is defined as not being in the 'end' phase.\n     *\n     * @type {Input[]}\n     */\n    this.active = [];\n\n    /**\n     * The array of latest point data for the currently active inputs, sourced\n     * from this.active.\n     *\n     * @type {westures-core.Point2D[]}\n     */\n    this.activePoints = [];\n\n    /**\n     * The centroid of the currently active points.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.centroid = {};\n\n    /**\n     * The latest event that the state processed.\n     *\n     * @type {Event}\n     */\n    this.event = null;\n  }\n\n  /**\n   * Deletes all inputs that are in the 'end' phase.\n   *\n   * @private\n   */\n  clearEndedInputs() {\n    this[symbols.inputs].forEach((v, k) => {\n      if (v.phase === 'end') this[symbols.inputs].delete(k);\n    });\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {Input[]} Inputs in the given phase.\n   */\n  getInputsInPhase(phase) {\n    return this.inputs.filter(i => i.phase === phase);\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {Input[]} Inputs <b>not</b> in the given phase.\n   */\n  getInputsNotInPhase(phase) {\n    return this.inputs.filter(i => i.phase !== phase);\n  }\n\n  /**\n   * @private\n   * @return {boolean} True if there are no active inputs. False otherwise.\n   */\n  hasNoInputs() {\n    return this[symbols.inputs].size === 0;\n  }\n\n  /**\n   * Update the input with the given identifier using the given event.\n   *\n   * @private\n   *\n   * @param {Event} event - The event being captured.\n   * @param {number} identifier - The identifier of the input to update.\n   */\n  updateInput(event, identifier) {\n    switch (PHASE[event.type]) {\n    case START:\n      this[symbols.inputs].set(\n        identifier,\n        new Input(event, identifier, this.source)\n      );\n      try {\n        this.element.setPointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n      break;\n    case END:\n      try {\n        this.element.releasePointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n      // All of 'end', 'move', and 'cancel' perform updates, hence the\n      // following fall-throughs\n    case CANCEL:\n    case MOVE:\n      if (this[symbols.inputs].has(identifier)) {\n        this[symbols.inputs].get(identifier).update(event);\n      }\n      break;\n    default:\n      console.warn(`Unrecognized event type: ${event.type}`);\n    }\n  }\n\n  /**\n   * Updates the inputs with new information based upon a new event being fired.\n   *\n   * @private\n   * @param {Event} event - The event being captured.\n   */\n  updateAllInputs(event) {\n    update_fns[event.constructor.name].call(this, event);\n    this.updateFields(event);\n  }\n\n  /**\n   * Updates the convenience fields.\n   *\n   * @private\n   * @param {Event} event - Event with which to update the convenience fields.\n   */\n  updateFields(event) {\n    this.inputs = Array.from(this[symbols.inputs].values());\n    this.active = this.getInputsNotInPhase('end');\n    this.activePoints = this.active.map(i => i.current.point);\n    this.centroid = Point2D.centroid(this.activePoints);\n    this.event = event;\n  }\n}\n\nmodule.exports = State;\n\n","/*\n * Contains various helpful utilities.\n */\n\n'use strict';\n\n/**\n * Performs a set filter operation.\n *\n * @private\n * @inner\n * @memberof westures-core.Region\n *\n * @param {Set} set - The set to filter.\n * @param {Function} predicate - Function to test elements of 'set'. Receives\n * one argument: the current set element.\n *\n * @return {Set} Set consisting of elements in 'set' for which 'predicate' is\n * true.\n */\nfunction setFilter(set, predicate) {\n  const result = new Set();\n  set.forEach(element => {\n    if (predicate(element)) {\n      result.add(element);\n    }\n  });\n  return result;\n}\n\n/**\n * Performs a set difference operation.\n *\n * @private\n * @inner\n * @memberof westures-core.Region\n *\n * @param {Set} left\n * @param {Set} right\n *\n * @return {Set} Set consisting of elements in 'left' that are not in\n * 'right'.\n */\nfunction setDifference(left, right) {\n  return setFilter(left, element => !right.has(element));\n}\n\nmodule.exports = Object.freeze({\n  setDifference,\n  setFilter,\n});\n\n","/*\n * Contains the Region class\n */\n\n'use strict';\n\nconst State = require('./State.js');\nconst {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  STATE_KEY_STRINGS,\n\n  PHASE,\n\n  CANCEL,\n  END,\n  START,\n} = require('./constants.js');\nconst {\n  setDifference,\n  setFilter,\n} = require('./utils.js');\n\n/**\n * Allows the user to specify the control region which will listen for user\n * input events.\n *\n * @memberof westures-core\n *\n * @param {Element} element - The element which should listen to input events.\n * @param {object} [options]\n * @param {boolean} [options.capture=false] - Whether the region uses the\n * capture phase of input events. If false, uses the bubbling phase.\n * @param {boolean} [options.preventDefault=true] - Whether the default\n * browser functionality should be disabled. This option should most likely be\n * ignored. Here there by dragons if set to false.\n * @param {string} [options.source='page'] - One of 'page', 'client', or\n * 'screen'. Determines what the source of (x,y) coordinates will be from the\n * input events. ('X' and 'Y' will be appended, then those are the properties\n * that will be looked up).\n */\nclass Region {\n  constructor(element, options = {}) {\n    const settings = { ...Region.DEFAULTS, ...options };\n\n    /**\n     * The list of relations between elements, their gestures, and the handlers.\n     *\n     * @private\n     * @type {Set.<Gesture>}\n     */\n    this.gestures = new Set();\n\n    /**\n     * The list of active gestures for the current input session.\n     *\n     * @private\n     * @type {Set.<Gesture>}\n     */\n    this.activeGestures = new Set();\n\n    /**\n     * The base list of potentially active gestures for the current input\n     * session.\n     *\n     * @private\n     * @type {Set.<Gesture>}\n     */\n    this.potentialGestures = new Set();\n\n    /**\n     * The element being bound to.\n     *\n     * @private\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the region listens for captures or bubbles.\n     *\n     * @private\n     * @type {boolean}\n     */\n    this.capture = settings.capture;\n\n    /**\n     * Whether the default browser functionality should be disabled. This option\n     * should most likely be ignored. Here there by dragons if set to false.\n     *\n     * @private\n     * @type {boolean}\n     */\n    this.preventDefault = settings.preventDefault;\n\n    /**\n     * Which X/Y attribute of input events should be used for determining input\n     * locations.\n     *\n     * @private\n     * @type {string}\n     */\n    this.source = settings.source;\n\n    /**\n     * The internal state object for a Region.  Keeps track of inputs.\n     *\n     * @private\n     * @type {State}\n     */\n    this.state = new State(this.element, this.source);\n\n    // Begin operating immediately.\n    this.activate();\n  }\n\n  /**\n   * Activates the region by adding event listeners for all appropriate input\n   * events to the region's element.\n   *\n   * @private\n   */\n  activate() {\n    /*\n     * Having to listen to both mouse and touch events is annoying, but\n     * necessary due to conflicting standards and browser implementations.\n     * Pointer is a fallback for now instead of the primary, until I figure out\n     * all the details to do with pointer-events and touch-action and their\n     * cross browser compatibility.\n     *\n     * Listening to both mouse and touch comes with the difficulty that\n     * preventDefault() must be called to prevent both events from iterating\n     * through the system. However I have left it as an option to the end user,\n     * which defaults to calling preventDefault(), in case there's a use-case I\n     * haven't considered or am not aware of.\n     *\n     * It is also a good idea to keep regions small in large pages.\n     *\n     * See:\n     *  https://www.html5rocks.com/en/mobile/touchandmouse/\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events\n     */\n    let eventNames = [];\n    if (window.TouchEvent || window.MouseEvent) {\n      eventNames = MOUSE_EVENTS.concat(TOUCH_EVENTS);\n    } else {\n      eventNames = POINTER_EVENTS;\n    }\n\n    // Bind detected browser events to the region element.\n    const arbitrate = this.arbitrate.bind(this);\n    eventNames.forEach(eventName => {\n      this.element.addEventListener(eventName, arbitrate, {\n        capture: this.capture,\n        once:    false,\n        passive: false,\n      });\n    });\n\n    const cancel = this.cancel.bind(this);\n    CANCEL_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, cancel);\n    });\n\n    const handleKeyboardEvent = this.handleKeyboardEvent.bind(this);\n    KEYBOARD_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, handleKeyboardEvent);\n    });\n  }\n\n  /**\n   * Handles a cancel event. Resets the state and the active / potential gesture\n   * lists.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  cancel(event) {\n    event.preventDefault();\n    this.state.inputs.forEach(input => {\n      input.update(event);\n    });\n    this.activeGestures.forEach(gesture => {\n      gesture.evaluateHook(CANCEL, this.state);\n    });\n    this.state = new State(this.element);\n    this.resetActiveGestures();\n  }\n\n  /**\n   * Handles a keyboard event, triggering a restart of any gestures that need\n   * it.\n   *\n   * @private\n   * @param {KeyboardEvent} event - The keyboard event.\n   */\n  handleKeyboardEvent(event) {\n    if (STATE_KEY_STRINGS.indexOf(event.key) >= 0) {\n      this.state.event = event;\n      const oldActiveGestures = this.activeGestures;\n      this.setActiveGestures();\n\n      setDifference(oldActiveGestures, this.activeGestures).forEach(gesture => {\n        gesture.evaluateHook(END, this.state);\n      });\n      setDifference(this.activeGestures, oldActiveGestures).forEach(gesture => {\n        gesture.evaluateHook(START, this.state);\n      });\n    }\n  }\n\n  /**\n   * Resets the active gestures.\n   *\n   * @private\n   */\n  resetActiveGestures() {\n    this.potentialGestures = new Set();\n    this.activeGestures = new Set();\n  }\n\n  /**\n   * Selects active gestures from the list of potentially active gestures.\n   *\n   * @private\n   */\n  setActiveGestures() {\n    this.activeGestures = setFilter(this.potentialGestures, gesture => {\n      return gesture.isEnabled(this.state);\n    });\n  }\n\n  /**\n   * Selects the potentially active gestures.\n   *\n   * @private\n   */\n  setPotentialGestures() {\n    const input = this.state.inputs[0];\n    this.potentialGestures = setFilter(this.gestures, gesture => {\n      return input.wasInitiallyInside(gesture.element);\n    });\n  }\n\n  /**\n   * Selects the gestures that are active for the current input sequence.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   * @param {boolean} isInitial - Whether this is an initial contact.\n   */\n  updateActiveGestures(event, isInitial) {\n    if (PHASE[event.type] === START) {\n      if (isInitial) {\n        this.setPotentialGestures();\n      }\n      this.setActiveGestures();\n    }\n  }\n\n  /**\n   * Evaluates whether the current input session has completed.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  pruneActiveGestures(event) {\n    if (PHASE[event.type] === END) {\n      if (this.state.hasNoInputs()) {\n        this.resetActiveGestures();\n      } else {\n        this.setActiveGestures();\n      }\n    }\n  }\n\n  /**\n   * All input events flow through this function. It makes sure that the input\n   * state is maintained, determines which gestures to analyze based on the\n   * initial position of the inputs, calls the relevant gesture hooks, and\n   * dispatches gesture data.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  arbitrate(event) {\n    const isInitial = this.state.hasNoInputs();\n    this.state.updateAllInputs(event);\n    this.updateActiveGestures(event, isInitial);\n\n    if (this.activeGestures.size > 0) {\n      if (this.preventDefault) event.preventDefault();\n\n      this.activeGestures.forEach(gesture => {\n        gesture.evaluateHook(PHASE[event.type], this.state);\n      });\n    }\n\n    this.state.clearEndedInputs();\n    this.pruneActiveGestures(event);\n  }\n\n  /**\n   * Adds the given gesture to the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  addGesture(gesture) {\n    this.gestures.add(gesture);\n  }\n\n  /**\n   * Removes the given gesture from the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  removeGesture(gesture) {\n    this.gestures.delete(gesture);\n    this.potentialGestures.delete(gesture);\n    this.activeGestures.delete(gesture);\n  }\n\n  /**\n   * Retrieves Gestures by their associated element.\n   *\n   * @private\n   *\n   * @param {Element} element - The element for which to find gestures.\n   *\n   * @return {Gesture[]} Gestures to which the element is bound.\n   */\n  getGesturesByElement(element) {\n    return setFilter(this.gestures, gesture => gesture.element === element);\n  }\n\n  /**\n   * Remove all gestures bound to the given element.\n   *\n   * @param {Element} element - The element to unbind.\n   */\n  removeGesturesByElement(element) {\n    this.getGesturesByElement(element).forEach(g => this.removeGesture(g));\n  }\n}\n\nRegion.DEFAULTS = Object.freeze({\n  capture:        false,\n  preventDefault: true,\n  source:         'page',\n});\n\nmodule.exports = Region;\n\n","/*\n * Contains the abstract Pinch class.\n */\n\n'use strict';\n\nconst cascade = Symbol('cascade');\nconst smooth = Symbol('smooth');\n\n/**\n * Determines whether to apply smoothing. Smoothing is on by default but turned\n * off if either:<br>\n *  1. The user explicitly requests that it be turned off.<br>\n *  2. The active pointer is not \"coarse\".<br>\n *\n * @see {@link\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia}\n *\n * @inner\n * @memberof westures-core.Smoothable\n *\n * @param {boolean} isRequested - Whether smoothing was requested by the user.\n *\n * @returns {boolean} Whether to apply smoothing.\n */\nfunction smoothingIsApplicable(isRequested) {\n  if (isRequested) {\n    try {\n      return window.matchMedia('(pointer: coarse)').matches;\n    } catch (e) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A Smoothable datatype is one that is capable of smoothing out a series of\n * values as they come in, one at a time, providing a more consistent series. It\n * does this by creating some inertia in the values using a cascading average.\n * (For those who are interested in such things, this effectively means that it\n * provides a practical application of Zeno's Dichotomy).\n *\n * @example\n * const x = new Smoothable({ identity: 1 });\n * const a = x.next(1);   // 1.0\n * const b = x.next(1.2); // 1.1\n * const c = x.next(0.9); // 1.0\n * const d = x.next(0.6); // 0.8\n * const e = x.next(1.2); // 1.0\n * const f = x.next(1.6); // 1.3\n * x.restart();\n * const g = x.next(0);   // 0.5\n *\n * @memberof westures-core\n *\n * @param {Object} [options]\n * @param {boolean} [options.applySmoothing=true] Whether to apply smoothing to\n * the data.\n * @param {*} [options.identity=0] The identity value of this smoothable data.\n */\nclass Smoothable {\n  constructor(options = {}) {\n    const final_options = { ...Smoothable.DEFAULTS, ...options };\n\n    /**\n     * The function through which smoothed emits are passed.\n     *\n     * @method\n     * @param {*} data - The data to emit.\n     *\n     * @return {*} The smoothed out data.\n     */\n    this.next = null;\n    if (smoothingIsApplicable(final_options.applySmoothing)) {\n      this.next = this[smooth].bind(this);\n    } else {\n      this.next = data => data;\n    }\n\n    /**\n     * The \"identity\" value of the data that will be smoothed.\n     *\n     * @type {*}\n     * @default 0\n     */\n    this.identity = final_options.identity;\n\n    /**\n     * The cascading average of outgoing values.\n     *\n     * @memberof westures-core.Smoothable\n     * @alias [@@cascade]\n     * @type {object}\n     */\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Restart the Smoothable gesture.\n   */\n  restart() {\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Smooth out the outgoing data.\n   *\n   * @memberof westures-core.Smoothable\n   * @alias [@@smooth]\n   * @param {object} data - The next batch of data to emit.\n   *\n   * @return {?object}\n   */\n  [smooth](data) {\n    const average = this.average(this[cascade], data);\n    this[cascade] = average;\n    return average;\n  }\n\n  /**\n   * Average out two values, as part of the smoothing algorithm. Override this\n   * method if the data being smoothed is not a Number.\n   *\n   * @param {number} a\n   * @param {number} b\n   *\n   * @return {number} The average of 'a' and 'b'\n   */\n  average(a, b) {\n    return (a + b) / 2;\n  }\n}\n\nSmoothable.DEFAULTS = Object.freeze({\n  applySmoothing: true,\n  identity:       0,\n});\n\nmodule.exports = Smoothable;\n\n","/**\n * The global API interface for Westures. Exposes a constructor for the Region\n * and the generic Gesture class for user gestures to implement, as well as the\n * Point2D and Smoothable datatypes.\n *\n * @namespace westures-core\n */\n\n'use strict';\n\nconst Gesture = require('./src/Gesture.js');\nconst Point2D = require('./src/Point2D.js');\nconst Region = require('./src/Region.js');\nconst Smoothable = require('./src/Smoothable.js');\n\nmodule.exports = {\n  Gesture,\n  Point2D,\n  Region,\n  Smoothable,\n};\n\n","/*\n * Contains the Pan class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Smoothable } = require('westures-core');\n\n/**\n * Data returned when a Pan is recognized.\n *\n * @typedef {Object} PanData\n * @mixes ReturnTypes.BaseData\n *\n * @property {westures.Point2D} translation - The change vector from the last\n * emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pan is defined as a normal movement in any direction.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.PanData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n */\nclass Pan extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Pan.DEFAULTS, ...options };\n    super('pan', element, handler, settings);\n\n    /**\n     * The previous point location.\n     *\n     * @private\n     * @type {westures.Point2D}\n     */\n    this.previous = null;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @private\n     * @override\n     * @type {westures-core.Smoothable<westures-core.Point2D>}\n     */\n    const identity = new Point2D(0, 0);\n    this.outgoing = new Smoothable({ ...settings, identity });\n    this.outgoing.average = (a, b) => Point2D.centroid([a, b]);\n  }\n\n  /**\n   * Resets the gesture's progress by saving the current centroid of the active\n   * inputs. To be called whenever the number of inputs changes.\n   *\n   * @private\n   * @param {State} state - The state object received by a hook.\n   */\n  restart(state) {\n    this.previous = state.centroid;\n    this.outgoing.restart();\n  }\n\n  /**\n   * Event hook for the start of a Pan. Records the current centroid of\n   * the inputs.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  start(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the move of a Pan.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.PanData} <tt>null</tt> if the gesture was muted or\n   * otherwise not recognized.\n   */\n  move(state) {\n    const translation = state.centroid.minus(this.previous);\n    this.previous = state.centroid;\n\n    return { translation: this.outgoing.next(translation) };\n  }\n\n  /**\n   * Event hook for the end of a Pan. Records the current centroid of\n   * the inputs.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  end(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the cancel of a Pan. Resets the current centroid of\n   * the inputs.\n   *\n   * @private\n   */\n  cancel() {\n    this.previous = null;\n    this.outgoing.restart();\n  }\n}\n\nPan.DEFAULTS = Object.freeze({\n  minInputs: 1,\n  smoothing: true,\n});\n\nmodule.exports = Pan;\n\n","/*\n * Contains the abstract Pinch class.\n */\n\n'use strict';\n\nconst { Gesture, Smoothable } = require('westures-core');\n\n/**\n * Data returned when a Pinch is recognized.\n *\n * @typedef {Object} PinchData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} distance - The average distance from an active input to\n *    the centroid.\n * @property {number} scale - The proportional change in distance since last\n * emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pinch is defined as two or more inputs moving either together or apart.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.PinchData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n */\nclass Pinch extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Pinch.DEFAULTS, ...options };\n    super('pinch', element, handler, settings);\n\n    /**\n     * The previous distance.\n     *\n     * @private\n     * @type {number}\n     */\n    this.previous = 0;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @private\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable({ ...settings, identity: 1 });\n  }\n\n  /**\n   * Initializes the gesture progress.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    this.previous = state.centroid.averageDistanceTo(state.activePoints);\n    this.outgoing.restart();\n  }\n\n  /**\n   * Event hook for the start of a Pinch.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  start(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the move of a Pinch.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.PinchData} <tt>null</tt> if not recognized.\n   */\n  move(state) {\n    const distance = state.centroid.averageDistanceTo(state.activePoints);\n    const scale = distance / this.previous;\n    this.previous = distance;\n\n    return { distance, scale: this.outgoing.next(scale) };\n  }\n\n  /**\n   * Event hook for the end of a Pinch.\n   *\n   * @private\n   * @param {State} input status object\n   */\n  end(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the cancel of a Pinch.\n   *\n   * @private\n   */\n  cancel() {\n    this.previous = 0;\n    this.outgoing.restart();\n  }\n}\n\nPinch.DEFAULTS = Object.freeze({\n  minInputs: 2,\n  smoothing: true,\n});\n\nmodule.exports = Pinch;\n\n","/*\n * Contains the Press class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D } = require('westures-core');\n\n/**\n * Data returned when a Press is recognized.\n *\n * @typedef {Object} PressData\n *\n * @property {westures.Point2D} centroid - The current centroid of the input\n * points.\n * @property {westures.Point2D} initial - The initial centroid of the input\n * points.\n * @property {number} distance - The total movement since initial contact.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Press is defined as one or more input points being held down.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.PressData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {Object} [options] - The options object.\n * @param {number} [options.delay=1000] - The delay before emitting, during\n * which time the number of inputs must not go below minInputs.\n * @param {number} [options.minInputs=1] - Number of inputs for a Press\n * gesture.\n * @param {number} [options.tolerance=10] - The tolerance in pixels a user can\n * move and still allow the gesture to emit.\n */\nclass Press extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Press.DEFAULTS, ...options };\n    super('press', element, handler, settings);\n\n    /**\n     * The delay before emitting a press event, during which time the number of\n     * inputs must not change.\n     *\n     * @private\n     * @type {number}\n     */\n    this.delay = settings.delay;\n\n    /**\n     * A move tolerance in pixels allows some slop between a user's start to end\n     * events. This allows the Press gesture to be triggered more easily.\n     *\n     * @private\n     * @type {number}\n     */\n    this.tolerance = settings.tolerance;\n\n    /**\n     * The initial centroid.\n     *\n     * @private\n     * @type {westures.Point2D}\n     */\n    this.initial = null;\n\n    /**\n     * Saves the timeout callback reference in case it needs to be cleared for\n     * some reason.\n     *\n     * @private\n     * @type {number}\n     */\n    this.timeout = null;\n  }\n\n  /**\n   * Event hook for the start of a gesture. If the number of active inputs is\n   * correct, initializes the timeout.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  start(state) {\n    this.initial = state.centroid;\n    this.timeout = setTimeout(() => this.recognize(state), this.delay);\n  }\n\n  /**\n   * Recognize a Press.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  recognize(state) {\n    const inputs = state.active.slice(0, this.minInputs);\n    const points = inputs.map(i => i.current.point);\n    const centroid = Point2D.centroid(points);\n    const distance = this.initial.distanceTo(centroid);\n    if (distance <= this.tolerance) {\n      this.handler({\n        distance,\n        centroid,\n        initial:  this.initial,\n        type:     this.type,\n      });\n    }\n  }\n\n  /**\n   * Event hook for the end of a gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  end(state) {\n    if (state.active.length < this.minInputs) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n  }\n}\n\nPress.DEFAULTS = Object.freeze({\n  delay:     1000,\n  tolerance: 10,\n  minInputs: 1,\n});\n\nmodule.exports = Press;\n\n","/*\n * Contains the abstract Pull class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Smoothable } = require('westures-core');\n\n/**\n * Data returned when a Pull is recognized.\n *\n * @typedef {Object} PullData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} distance - The average distance from an active input to\n * the centroid.\n * @property {number} scale - The proportional change in distance since last\n * emit.\n * @property {westures.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pull is defined as a single input moving away from or towards a pivot\n * point.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.PullData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {Object} [options]\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {string} [options.enableKey=null] - One of 'altKey', 'ctrlKey',\n * 'metaKey', or 'shiftKey'. If set, gesture will only be recognized while this\n * key is down.\n * @param {number} [options.minInputs=1] The minimum number of inputs that\n * must be active for a Pull to be recognized.\n * @param {Element} [options.pivotCenter] - If set, the pull's pivot point will\n * be set to the center of the given pivotCenter element. Otherwise, the pivot\n * will be the location of the first contact point.\n */\nclass Pull extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Pull.DEFAULTS, ...options };\n    super('pinch', element, handler, settings);\n\n    /**\n     * The radius around the start point in which to do nothing.\n     *\n     * @private\n     * @type {number}\n     */\n    this.deadzoneRadius = settings.deadzoneRadius;\n\n    /**\n     * If this is set, the pull will use the center of the element as its pivot\n     * point. Unreliable if the element is moved during a pull gesture.\n     *\n     * @private\n     * @type {Element}\n     */\n    this.pivotCenter = settings.pivotCenter;\n\n    /**\n     * The pivot point of the pull.\n     *\n     * @private\n     * @type {westures.Point2D}\n     */\n    this.pivot = null;\n\n    /**\n     * The previous distance.\n     *\n     * @private\n     * @type {number}\n     */\n    this.previous = 0;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @private\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable({ ...settings, identity: 1 });\n  }\n\n  /**\n   * Restart the given progress object using the given input object.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    if (this.pivotCenter) {\n      const rect = this.pivotCenter.getBoundingClientRect();\n      this.pivot = new Point2D(\n        rect.left + (rect.width / 2),\n        rect.top + (rect.height / 2)\n      );\n      this.previous = this.pivot.distanceTo(state.centroid);\n    } else {\n      this.pivot = state.centroid;\n      this.previous = 0;\n    }\n    this.outgoing.restart();\n  }\n\n  /**\n   * Determine the data to emit. To be called once valid state for a pull has\n   * been assured, except for deadzone.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?Returns.PullData} Data to emit.\n   */\n  calculateOutput(state) {\n    const pivot = this.pivot;\n    const distance = pivot.distanceTo(state.centroid);\n    const scale = distance / this.previous;\n\n    let returnValue = null;\n    if (distance > this.deadzoneRadius && this.previous > this.deadzoneRadius) {\n      returnValue = { distance, scale, pivot };\n    }\n\n    /*\n     * Updating the previous distance regardless of emit prevents sudden changes\n     * when the user exits the deadzone circle.\n     */\n    this.previous = distance;\n\n    return returnValue;\n  }\n\n  /**\n   * Event hook for the start of a Pull.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  start(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the move of a Pull.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.PullData} <tt>null</tt> if not recognized.\n   */\n  move(state) {\n    const output = this.calculateOutput(state);\n    if (output) {\n      return { scale: this.outgoing.next(output) };\n    }\n    return null;\n  }\n\n  /**\n   * Event hook for the end of a Pull.\n   *\n   * @private\n   * @param {State} input status object\n   */\n  end(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the cancel of a Pull.\n   *\n   * @private\n   */\n  cancel() {\n    this.outgoing.restart();\n  }\n}\n\nPull.DEFAULTS = Object.freeze({\n  deadzoneRadius: 15,\n  minInputs:      1,\n  pivotCenter:    false,\n  smoothing:      true,\n});\n\nmodule.exports = Pull;\n\n","/*\n * Constains the angularMinus() function\n */\n\n'use strict';\n\nconst PI2 = 2 * Math.PI;\n\n/**\n * Helper function to regulate angular differences, so they don't jump from 0 to\n * 2*PI or vice versa.\n *\n * @private\n * @param {number} a - Angle in radians.\n * @param {number} b - Angle in radians.\n * @return {number} c, given by: c = a - b such that || < PI\n */\nfunction angularMinus(a, b = 0) {\n  let diff = a - b;\n  if (diff < -Math.PI) {\n    diff += PI2;\n  } else if (diff > Math.PI) {\n    diff -= PI2;\n  }\n  return diff;\n}\n\nmodule.exports = angularMinus;\n\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { Gesture, Smoothable } = require('westures-core');\nconst angularMinus = require('./angularMinus.js');\n\n/**\n * Data returned when a Rotate is recognized.\n *\n * @typedef {Object} RotateData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Rotate is defined as two inputs moving with a changing angle between them.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.RotateData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {Object} [options]\n * @param {number} [options.minInputs=2] The minimum number of inputs that must\n * be active for a Rotate to be recognized.\n * @param {boolean} [options.smoothing=true] Whether to apply smoothing to\n * emitted data.\n */\nclass Rotate extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Rotate.DEFAULTS, ...options };\n    super('rotate', element, handler, settings);\n\n    /**\n     * The minimum number of inputs that must be active for a Pinch to be\n     * recognized.\n     *\n     * @private\n     * @type {number}\n     */\n    this.minInputs = settings.minInputs;\n\n    /**\n     * Track the previously emitted rotation angle.\n     *\n     * @private\n     * @type {number[]}\n     */\n    this.previousAngles = [];\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @private\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable(settings);\n  }\n\n  /**\n   * Store individual angle progress on each input, return average angle change.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  getAngle(state) {\n    let angle = 0;\n    const stagedAngles = [];\n\n    state.active.forEach((input, idx) => {\n      const currentAngle = state.centroid.angleTo(input.current.point);\n      angle += angularMinus(currentAngle, this.previousAngles[idx]);\n      stagedAngles[idx] = currentAngle;\n    });\n\n    angle /= (state.active.length);\n    this.previousAngles = stagedAngles;\n    return angle;\n  }\n\n  /**\n   * Restart the gesture;\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    this.previousAngles = [];\n    this.getAngle(state);\n    this.outgoing.restart();\n  }\n\n  /**\n   * Event hook for the start of a gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  start(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the move of a Rotate gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.RotateData} <tt>null</tt> if this event did not occur\n   */\n  move(state) {\n    const rotation = this.getAngle(state);\n    if (rotation) {\n      return { rotation: this.outgoing.next(rotation) };\n    }\n    return null;\n  }\n\n  /**\n   * Event hook for the end of a gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  end(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the cancel of a gesture.\n   *\n   * @private\n   */\n  cancel() {\n    this.outgoing.restart();\n  }\n}\n\nRotate.DEFAULTS = Object.freeze({\n  minInputs: 2,\n  smoothing: true,\n});\n\nmodule.exports = Rotate;\n\n","/*\n * Contains the Swipe class.\n */\n\n'use strict';\n\nconst { Gesture } = require('westures-core');\n\nconst PROGRESS_STACK_SIZE = 7;\nconst MS_THRESHOLD = 300;\n\n/**\n * Data returned when a Swipe is recognized.\n *\n * @typedef {Object} SwipeData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} velocity - The velocity of the swipe.\n * @property {number} direction - In radians, the direction of the swipe.\n * @property {westures.Point2D} point - The point at which the swipe ended.\n * @property {number} time - The epoch time, in ms, when the swipe ended.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * Calculates the angle of movement along a series of moves.\n *\n * @private\n * @inner\n * @memberof westures.Swipe\n * @see {@link https://en.wikipedia.org/wiki/Mean_of_circular_quantities}\n *\n * @param {{time: number, point: westures-core.Point2D}} moves - The moves list\n * to process.\n * @param {number} vlim - The number of moves to process.\n *\n * @return {number} The angle of the movement.\n */\nfunction calc_angle(moves, vlim) {\n  const point = moves[vlim].point;\n  let sin = 0;\n  let cos = 0;\n  for (let i = 0; i < vlim; ++i) {\n    const angle = moves[i].point.angleTo(point);\n    sin += Math.sin(angle);\n    cos += Math.cos(angle);\n  }\n  sin /= vlim;\n  cos /= vlim;\n  return Math.atan2(sin, cos);\n}\n\n/**\n * Local helper function for calculating the velocity between two timestamped\n * points.\n *\n * @private\n * @inner\n * @memberof westures.Swipe\n *\n * @param {object} start\n * @param {westures.Point2D} start.point\n * @param {number} start.time\n * @param {object} end\n * @param {westures.Point2D} end.point\n * @param {number} end.time\n *\n * @return {number} velocity from start to end point.\n */\nfunction velocity(start, end) {\n  const distance = end.point.distanceTo(start.point);\n  const time = end.time - start.time + 1;\n  return distance / time;\n}\n\n/**\n * Calculates the veloctiy of movement through a series of moves.\n *\n * @private\n * @inner\n * @memberof westures.Swipe\n *\n * @param {{time: number, point: westures-core.Point2D}} moves - The moves list\n * to process.\n * @param {number} vlim - The number of moves to process.\n *\n * @return {number} The velocity of the moves.\n */\nfunction calc_velocity(moves, vlim) {\n  let max = 0;\n  for (let i = 0; i < vlim; ++i) {\n    const current = velocity(moves[i], moves[i + 1]);\n    if (current > max) max = current;\n  }\n  return max;\n}\n\n/**\n * A swipe is defined as input(s) moving in the same direction in an relatively\n * increasing velocity and leaving the screen at some point before it drops\n * below it's escape velocity.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.SwipeData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n */\nclass Swipe extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('swipe', element, handler, options);\n\n    /**\n     * Moves list.\n     *\n     * @private\n     * @type {object[]}\n     */\n    this.moves = [];\n\n    /**\n     * Data to emit when all points have ended.\n     *\n     * @private\n     * @type {ReturnTypes.SwipeData}\n     */\n    this.saved = null;\n  }\n\n  /**\n   * Refresh the swipe state.\n   *\n   * @private\n   */\n  restart() {\n    this.moves = [];\n    this.saved = null;\n  }\n\n  /**\n   * Event hook for the start of a gesture. Resets the swipe state.\n   *\n   * @private\n   */\n  start() {\n    this.restart();\n  }\n\n  /**\n   * Event hook for the move of a gesture. Captures an input's x/y coordinates\n   * and the time of it's event on a stack.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  move(state) {\n    this.moves.push({\n      time:  Date.now(),\n      point: state.centroid,\n    });\n\n    if (this.moves.length > PROGRESS_STACK_SIZE) {\n      this.moves.splice(0, this.moves.length - PROGRESS_STACK_SIZE);\n    }\n  }\n\n  /**\n   * Determines if the input's history validates a swipe motion.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.SwipeData} <tt>null</tt> if the gesture is not\n   * recognized.\n   */\n  end(state) {\n    const result = this.getResult();\n    this.moves = [];\n\n    if (state.active.length > 0) {\n      this.saved = result;\n      return null;\n    }\n\n    this.saved = null;\n    return this.validate(result);\n  }\n\n  /**\n   * Event hook for the cancel phase of a Swipe.\n   *\n   * @private\n   */\n  cancel() {\n    this.restart();\n  }\n\n  /**\n   * Get the swipe result.\n   *\n   * @private\n   */\n  getResult() {\n    if (this.moves.length < PROGRESS_STACK_SIZE) {\n      return this.saved;\n    }\n    const vlim = PROGRESS_STACK_SIZE - 1;\n    const { point, time } = this.moves[vlim];\n    const velocity = calc_velocity(this.moves, vlim);\n    const direction = calc_angle(this.moves, vlim);\n    const centroid = point;\n    return { point, velocity, direction, time, centroid };\n  }\n\n  /**\n   * Validates that an emit should occur with the given data.\n   *\n   * @private\n   * @param {?ReturnTypes.SwipeData} data\n   */\n  validate(data) {\n    if (data == null) return null;\n    return (Date.now() - data.time > MS_THRESHOLD) ? null : data;\n  }\n}\n\nmodule.exports = Swipe;\n\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Smoothable } = require('westures-core');\nconst angularMinus = require('./angularMinus.js');\n\n/**\n * Data returned when a Swivel is recognized.\n *\n * @typedef {Object} SwivelData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n * @property {westures.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Swivel is a single input rotating around a fixed point. The fixed point is\n * determined by the input's location at its 'start' phase.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.SwivelData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {Object} [options]\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {string} [options.enableKey=null] - One of 'altKey', 'ctrlKey',\n * 'metaKey', or 'shiftKey'. If set, gesture will only be recognized while this\n * key is down.\n * @param {number} [options.minInputs=1] - The minimum number of inputs that\n * must be active for a Swivel to be recognized.\n * @param {Element} [options.pivotCenter] - If set, the swivel's pivot point\n * will be set to the center of the given pivotCenter element. Otherwise, the\n * pivot will be the location of the first contact point.\n */\nclass Swivel extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Swivel.DEFAULTS, ...options };\n    super('swivel', element, handler, settings);\n\n    /**\n     * The radius around the start point in which to do nothing.\n     *\n     * @private\n     * @type {number}\n     */\n    this.deadzoneRadius = settings.deadzoneRadius;\n\n    /**\n     * If this is set, the swivel will use the center of the element as its\n     * pivot point. Unreliable if the element is moved during a swivel gesture.\n     *\n     * @private\n     * @type {Element}\n     */\n    this.pivotCenter = settings.pivotCenter;\n\n    /**\n     * The pivot point of the swivel.\n     *\n     * @private\n     * @type {westures.Point2D}\n     */\n    this.pivot = null;\n\n    /**\n     * The previous angle.\n     *\n     * @private\n     * @type {number}\n     */\n    this.previous = 0;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @private\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable(settings);\n  }\n\n  /**\n   * Restart the given progress object using the given input object.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    if (this.pivotCenter) {\n      const rect = this.pivotCenter.getBoundingClientRect();\n      this.pivot = new Point2D(\n        rect.left + (rect.width / 2),\n        rect.top + (rect.height / 2)\n      );\n      this.previous = this.pivot.angleTo(state.centroid);\n    } else {\n      this.pivot = state.centroid;\n      this.previous = 0;\n    }\n    this.outgoing.restart();\n  }\n\n  /**\n   * Event hook for the start of a Swivel gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  start(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Determine the data to emit. To be called once valid state for a swivel has\n   * been assured, except for deadzone.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?Returns.SwivelData} Data to emit.\n   */\n  calculateOutput(state) {\n    const pivot = this.pivot;\n    const angle = pivot.angleTo(state.centroid);\n    const rotation = angularMinus(angle, this.previous);\n\n    /*\n     * Updating the previous angle regardless of emit prevents sudden flips when\n     * the user exits the deadzone circle.\n     */\n    this.previous = angle;\n\n    if (pivot.distanceTo(state.centroid) > this.deadzoneRadius) {\n      return { rotation, pivot };\n    }\n    return null;\n  }\n\n  /**\n   * Event hook for the move of a Swivel gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.SwivelData} <tt>null</tt> if the gesture is not\n   * recognized.\n   */\n  move(state) {\n    const output = this.calculateOutput(state);\n    if (output) {\n      return { rotation: this.outgoing.next(output) };\n    }\n    return null;\n  }\n\n  /**\n   * Event hook for the end of a Swivel.\n   *\n   * @private\n   * @param {State} state - current input state.\n   */\n  end(state) {\n    this.restart(state);\n  }\n\n  /**\n   * Event hook for the cancel of a Swivel.\n   *\n   * @private\n   */\n  cancel() {\n    this.outgoing.restart();\n  }\n}\n\nSwivel.DEFAULTS = Object.freeze({\n  deadzoneRadius: 15,\n  minInputs:      1,\n  pivotCenter:    false,\n});\n\nmodule.exports = Swivel;\n\n","/*\n * Contains the Tap class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D } = require('westures-core');\n\n/**\n * Data returned when a Tap is recognized.\n *\n * @typedef {Object} TapData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} x - x coordinate of tap point.\n * @property {number} y - y coordinate of tap point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Tap is defined as a touchstart to touchend event in quick succession.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.TapData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {Object} [options] - The options object.\n * @param {number} [options.minDelay=0] - The minimum delay between a touchstart\n * and touchend can be configured in milliseconds.\n * @param {number} [options.maxDelay=300] - The maximum delay between a\n * touchstart and touchend can be configured in milliseconds.\n * @param {number} [options.numTaps=1] - Number of taps to require.\n * @param {number} [options.tolerance=10] - The tolerance in pixels a user can\n * move.\n */\nclass Tap extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Tap.DEFAULTS, ...options };\n    super('tap', element, handler, settings);\n\n    /**\n     * The minimum amount between a touchstart and a touchend can be configured\n     * in milliseconds. The minimum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     *\n     * @private\n     * @type {number}\n     */\n    this.minDelay = settings.minDelay;\n\n    /**\n     * The maximum delay between a touchstart and touchend can be configured in\n     * milliseconds. The maximum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     *\n     * @private\n     * @type {number}\n     */\n    this.maxDelay = settings.maxDelay;\n\n    /**\n     * The number of inputs to trigger a Tap can be variable, and the maximum\n     * number being a factor of the browser.\n     *\n     * @private\n     * @type {number}\n     */\n    this.numTaps = settings.numTaps;\n\n    /**\n     * A move tolerance in pixels allows some slop between a user's start to end\n     * events. This allows the Tap gesture to be triggered more easily.\n     *\n     * @private\n     * @type {number}\n     */\n    this.tolerance = settings.tolerance;\n\n    /**\n     * An array of inputs that have ended recently.\n     *\n     * @private\n     * @type {Input[]}\n     */\n    this.taps = [];\n  }\n\n  /**\n   * Event hook for the end of a gesture.  Determines if this the tap event can\n   * be fired if the delay and tolerance constraints are met.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.TapData} <tt>null</tt> if the gesture is not to be\n   * emitted, Object with information otherwise.\n   */\n  end(state) {\n    const now = Date.now();\n\n    // Save the recently ended inputs as taps.\n    this.taps = this.taps.concat(state.getInputsInPhase('end'))\n      .filter(input => {\n        const tdiff = now - input.startTime;\n        return tdiff <= this.maxDelay && tdiff >= this.minDelay;\n      });\n\n    // Validate the list of taps.\n    if (this.taps.length !== this.numTaps ||\n      this.taps.some(i => i.totalDistance() > this.tolerance)) {\n      return null;\n    }\n\n    const centroid = Point2D.centroid(this.taps.map(i => i.current.point));\n    this.taps = []; // Critical! Used taps need to be cleared!\n    return { centroid, ...centroid };\n  }\n}\n\nTap.DEFAULTS = Object.freeze({\n  minDelay:  0,\n  maxDelay:  300,\n  numTaps:   1,\n  tolerance: 10,\n});\n\nmodule.exports = Tap;\n\n","/*\n * Contains the Track class.\n */\n\n'use strict';\n\nconst { Gesture } = require('westures-core');\n\n/**\n * Data returned when a Track is recognized.\n *\n * @typedef {Object} TrackData\n * @mixes ReturnTypes.BaseData\n *\n * @property {westures.Point2D[]} active - Points currently in 'start' or 'move'\n *    phase.\n * @property {westures.Point2D} centroid - centroid of currently active points.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Track gesture forwards a list of active points and their centroid on each\n * of the selected phases.\n *\n * @extends westures.Gesture\n * @see ReturnTypes.TrackData\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {Object} [options]\n * @param {string[]} [options.phases=[]] Phases to recognize. Entries can be any\n * or all of 'start', 'move', 'end', and 'cancel'.\n */\nclass Track extends Gesture {\n  constructor(element, handler, options = {}) {\n    const settings = { ...Track.DEFAULTS, ...options };\n    super('track', element, handler, settings);\n\n    this.trackStart  = settings.phases.includes('start');\n    this.trackMove   = settings.phases.includes('move');\n    this.trackEnd    = settings.phases.includes('end');\n    this.trackCancel = settings.phases.includes('cancel');\n  }\n\n  /**\n   * Filters out the state's data, down to what should be emitted.\n\n   * @private\n   * @param {State} state - current input state.\n   * @return {ReturnTypes.TrackData}\n   */\n  data({ activePoints, centroid }) {\n    return { active: activePoints, centroid };\n  }\n\n  /**\n   * Event hook for the start of a Track gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.TrackData} <tt>null</tt> if not recognized.\n   */\n  start(state) {\n    return this.trackStart ? this.data(state) : null;\n  }\n\n  /**\n   * Event hook for the move of a Track gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.TrackData} <tt>null</tt> if not recognized.\n   */\n  move(state) {\n    return this.trackMove ? this.data(state) : null;\n  }\n\n  /**\n   * Event hook for the end of a Track gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.TrackData} <tt>null</tt> if not recognized.\n   */\n  end(state) {\n    return this.trackEnd ? this.data(state) : null;\n  }\n\n  /**\n   * Event hook for the cancel of a Track gesture.\n   *\n   * @private\n   * @param {State} state - current input state.\n   * @return {?ReturnTypes.TrackData} <tt>null</tt> if not recognized.\n   */\n  cancel(state) {\n    return this.trackCancel ? this.data(state) : null;\n  }\n}\n\n// Default settings.\nTrack.DEFAULTS = Object.freeze({\n  phases: [],\n});\n\nmodule.exports = Track;\n\n","/**\n * The API interface for Westures. Defines a number of gestures on top of the\n * engine provided by {@link\n * https://mvanderkamp.github.io/westures-core/index.html|westures-core}.\n *\n * @namespace westures\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Region, Smoothable } = require('westures-core');\n\nconst Pan     = require('./src/Pan.js');\nconst Pinch   = require('./src/Pinch.js');\nconst Press   = require('./src/Press.js');\nconst Pull    = require('./src/Pull.js');\nconst Rotate  = require('./src/Rotate.js');\nconst Swipe   = require('./src/Swipe.js');\nconst Swivel  = require('./src/Swivel.js');\nconst Tap     = require('./src/Tap.js');\nconst Track   = require('./src/Track.js');\n\nmodule.exports = {\n  Gesture,\n  Point2D,\n  Region,\n  Smoothable,\n  Pan,\n  Pinch,\n  Press,\n  Pull,\n  Rotate,\n  Swipe,\n  Swivel,\n  Tap,\n  Track,\n};\n\n/**\n * Here are the return \"types\" of the gestures that are included in this\n * package.\n *\n * @namespace ReturnTypes\n */\n\n/**\n * The base Gesture class which all other classes extend.\n *\n * @see {@link\n * https://mvanderkamp.github.io/westures-core/westures-core.Gesture.html|\n * westures-core.Gesture}\n *\n * @class Gesture\n * @memberof westures\n */\n\n/**\n * The Region class, which is the entry point for the Westures system, through\n * which you bind handlers with gestures and elements.\n *\n * @see {@link\n * https://mvanderkamp.github.io/westures-core/westures-core.Region.html|\n * westures-core.Region}\n *\n * @class Region\n * @memberof westures\n */\n\n/**\n * Provides some basic operations on two-dimensional points.\n *\n * @see {@link\n * https://mvanderkamp.github.io/westures-core/westures-core.Point2D.html|\n * westures-core.Point2D}\n *\n * @class Point2D\n * @memberof westures\n */\n\n/**\n * Allows the enabling of smoothing on Gestures that use this mixin.\n *\n * @see {@link\n * https://mvanderkamp.github.io/westures-core/westures-core.Smoothable.html|\n * westures-core.Smoothable}\n *\n * @mixin Smoothable\n * @memberof westures\n */\n\n/**\n * The base data that is included for all emitted gestures.\n *\n * @typedef {Object} BaseData\n *\n * @property {westures.Point2D} centroid - The centroid of the input points.\n * @property {Event} event - The input event which caused the gesture to be\n * recognized.\n * @property {string} phase - 'start', 'move', 'end', or 'cancel'.\n * @property {number} radius - The distance of the furthest input to the\n * centroid.\n * @property {string} type - The name of the gesture as specified by its\n * designer.\n * @property {Element} target - The bound target of the gesture.\n *\n * @memberof ReturnTypes\n */\n\n"]}