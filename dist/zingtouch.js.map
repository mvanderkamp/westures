{"version":3,"sources":["webpack:///webpack/bootstrap bb6e4a57ffbdb7a6b98d","webpack:///./src/core/main.js","webpack:///./src/ZingTouch.js","webpack:///./src/core/classes/Region.js","webpack:///./src/core/classes/Binder.js","webpack:///./src/gestures/Gesture.js","webpack:///./src/core/util.js","webpack:///./src/core/arbiter.js","webpack:///./src/core/dispatcher.js","webpack:///./src/core/interpreter.js","webpack:///./src/core/classes/State.js","webpack:///./src/gestures/Expand.js","webpack:///./src/gestures/Distance.js","webpack:///./src/gestures/Pan.js","webpack:///./src/gestures/Pinch.js","webpack:///./src/gestures/Rotate.js","webpack:///./src/gestures/Swipe.js","webpack:///./src/gestures/Tap.js","webpack:///./src/core/classes/Binding.js","webpack:///./src/core/classes/Input.js","webpack:///./src/core/classes/ZingEvent.js"],"names":["window","ZingTouch","_regions","Gesture","Expand","Pan","Pinch","Rotate","Swipe","Tap","Region","element","capture","preventDefault","id","length","region","push","state","eventNames","PointerEvent","TouchEvent","map","name","addEventListener","e","gesture","handler","bindOnce","tagName","addBinding","bind","bindings","retrieveBindingsByElement","unbound","forEach","binding","registeredGestures","registeredGesture","removeEventListener","getId","key","Error","setType","registerGesture","getType","Binder","Object","keys","type","object","inputs","valid","input","isInside","initial","x","y","CIRCLE_DEGREES","HALF_CIRCLE_DEGREES","util","normalizeEvent","isWithin","currentX","currentY","previousX","previousY","tolerance","Math","abs","distanceBetweenTwoPoints","x0","x1","y0","y1","dist","sqrt","round","getMidpoint","getAngle","originX","originY","projectionX","projectionY","angle","atan2","PI","getAngularDistance","start","end","sign","getVelocity","startX","startY","startTime","endX","endY","endTime","distance","getRightMostInput","rightMost","Number","MIN_VALUE","isInteger","value","target","rect","getBoundingClientRect","left","width","top","height","getPropagationPath","event","path","node","document","parentNode","getPathIndex","index","obj","i","setMSPreventDefault","style","removeMSPreventDefault","arbiter","buttons","resetInputs","updateInputs","retrieveBindingsByInitialPos","returnValue","toBeDispatched","gestures","data","events","endCount","getCurrentEventType","dispatcher","newEvent","CustomEvent","detail","bubbles","cancelable","emitEvent","dispatchEvent","unbind","interpreter","evType","candidates","result","current","DEFAULT_MOUSE_ID","State","regionId","numGestures","boundGesture","indexOf","assignGestureId","matches","inputsInside","filter","regionElement","identifier","eventType","touches","pointerType","changedTouches","hasOwnProperty","parseInt","update","pointerId","findInputById","endType","setId","options","DEFAULT_INPUTS","DEFAULT_MIN_THRESHOLD","Distance","threshold","isValid","progress","getGestureProgress","lastEmittedDistance","numActiveInputs","currentDistance","lastDistance","previous","centerPoint","center","numInputs","active","lastEmitted","output","reachedThreshold","yThreshold","xThreshold","distanceFromOrigin","directionFromOrigin","currentDirection","MAX_INPUTS","referencePivot","diffX","diffY","bRect","currentPivot","currentAngle","initialAngle","previousAngle","change","distanceFromLast","DEFAULT_MAX_REST_TIME","DEFAULT_ESCAPE_VELOCITY","DEFAULT_TIME_DISTORTION","DEFAULT_MAX_PROGRESS_STACK","maxRestTime","escapeVelocity","timeDistortion","maxProgressStack","moves","time","Date","getTime","shift","currentMove","pop","lastMove","velocity","DEFAULT_MIN_DELAY_MS","DEFAULT_MAX_DELAY_MS","DEFAULT_MOVE_PX_TOLERANCE","minDelay","maxDelay","resetProgress","MAX_VALUE","interval","Binding","Input","currentEvent","touchIdentifier","INITIAL_COORDINATE","ZingEvent","originalEvent","eventObj","clientX","clientY","pageX","pageY","screenX","screenY"],"mappings":"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","file":"/Users/mike/zingtouch/dist/zingtouch.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bb6e4a57ffbdb7a6b98d","/**\n * @file main.js\n * Main file to setup event listeners on the document,\n * and to expose the ZingTouch object\n */\n\nimport ZingTouch from './../ZingTouch.js';\nwindow.ZingTouch = ZingTouch;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/main.js","/**\n * @file ZingTouch.js\n * Main object containing API methods and Gesture constructors\n */\n\nimport Region from './core/classes/Region.js';\nimport Gesture from './gestures/Gesture.js';\nimport Expand from './gestures/Expand.js';\nimport Pan from './gestures/Pan.js';\nimport Pinch from './gestures/Pinch.js';\nimport Rotate from './gestures/Rotate.js';\nimport Swipe from './gestures/Swipe.js';\nimport Tap from './gestures/Tap.js';\n\n/**\n * The global API interface for ZingTouch. Contains a constructor for the\n * Region Object, and constructors for each predefined Gesture.\n * @type {Object}\n * @namespace ZingTouch\n */\nlet ZingTouch = {\n  _regions: [],\n\n  // Constructors\n  Gesture: Gesture,\n  Expand: Expand,\n  Pan: Pan,\n  Pinch: Pinch,\n  Rotate: Rotate,\n  Swipe: Swipe,\n  Tap: Tap,\n  Region: function(element, capture, preventDefault) {\n    let id = ZingTouch._regions.length;\n    let region = new Region(element, capture, preventDefault, id);\n    ZingTouch._regions.push(region);\n    return region;\n  },\n};\n\nexport default ZingTouch;\n\n\n\n// WEBPACK FOOTER //\n// ./src/ZingTouch.js","/**\n * @file Region.js\n */\n\nimport Binder from './Binder.js';\nimport Gesture from './../../gestures/Gesture.js';\nimport arbiter from './../arbiter.js';\nimport State from './State.js';\n\n/**\n * Allows the user to specify a region to capture all events to feed ZingTouch\n * into. This can be as narrow as the element itself, or as big as the document\n * itself. The more specific an area, the better performant the overall\n * application will perform. Contains API methods to bind/unbind specific\n * elements to corresponding gestures. Also contains the ability to\n * register/unregister new gestures.\n * @class Region\n */\nclass Region {\n\n  /**\n   * Constructor function for the Region class.\n   * @param {Element} element - The element to capture all\n   *  window events in that region to feed into ZingTouch.\n   * @param {boolean} [capture=false] - Whether the region listens for\n   *  captures or bubbles.\n   * @param {boolean} [preventDefault=true] - Whether the default browser\n   *  functionality should be disabled;\n   * @param {Number} id - The id of the region, assigned by the ZingTouch object\n   */\n  constructor(element, capture, preventDefault, id) {\n    /**\n     * The identifier for the Region. This is assigned by the ZingTouch object\n     * and is used to hash gesture id for uniqueness.\n     * @type {Number}\n     */\n    this.id = id;\n\n    /**\n     * The element being bound to.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the region listens for captures or bubbles.\n     * @type {boolean}\n     */\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\n\n    /**\n     * Boolean to disable browser functionality such as scrolling and zooming\n     * over the region\n     * @type {boolean}\n     */\n    this.preventDefault = (typeof preventDefault !== 'undefined') ?\n      preventDefault : true;\n\n    /**\n     * The internal state object for a Region.\n     * Keeps track of registered gestures, inputs, and events.\n     * @type {State}\n     */\n    this.state = new State(id);\n\n    let eventNames = [];\n    if (window.PointerEvent && !window.TouchEvent) {\n      eventNames = [\n        'pointerdown',\n        'pointermove',\n        'pointerup',\n      ];\n    } else {\n      eventNames = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'touchstart',\n        'touchmove',\n        'touchend',\n      ];\n    }\n\n    // Bind detected browser events to the region element.\n    eventNames.map((name) => {\n      element.addEventListener(name, (e) => {\n        arbiter(e, this);\n      }, this.capture);\n    });\n  }\n\n  /**\n   * Bind an element to a registered/unregistered gesture with\n   * multiple function signatures.\n   * @example\n   * bind(element) - chainable\n   * @example\n   * bind(element, gesture, handler, [capture])\n   * @param {Element} element - The element object.\n   * @param {String|Object} [gesture] - Gesture key, or a Gesture object.\n   * @param {Function} [handler] - The function to execute when an event is\n   *  emitted.\n   * @param {Boolean} [capture] - capture/bubble\n   * @param {Boolean} [bindOnce = false] - Option to bind once and\n   *  only emit the event once.\n   * @return {Object} - a chainable object that has the same function as bind.\n   */\n  bind(element, gesture, handler, capture, bindOnce) {\n    if (!element || (element && !element.tagName)) {\n      throw 'Bind must contain an element';\n    }\n\n    bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\n    if (!gesture) {\n      return new Binder(element, bindOnce, this.state);\n    } else {\n      this.state.addBinding(element, gesture, handler, capture, bindOnce);\n    }\n  }\n\n  /**\n   * Bind an element and sets up actions to remove the binding once\n   * it has been emitted for the first time.\n   * 1. bind(element) - chainable\n   * 2. bind(element, gesture, handler, [capture])\n   * @param {Element} element - The element object.\n   * @param {String|Object} gesture - Gesture key, or a Gesture object.\n   * @param {Function} handler - The function to execute when an\n   *  event is emitted.\n   * @param {Boolean} capture - capture/bubble\n   * @return {Object} - a chainable object that has the same function as bind.\n   */\n  bindOnce(element, gesture, handler, capture) {\n    this.bind(element, gesture, handler, capture, true);\n  }\n\n  /**\n   * Unbinds an element from either the specified gesture\n   *  or all if no element is specified.\n   * @param {Element} element -The element to remove.\n   * @param {String | Object} [gesture] - A String representing the gesture,\n   *   or the actual object being used.\n   * @return {Array} - An array of Bindings that were unbound to the element;\n   */\n  unbind(element, gesture) {\n    let bindings = this.state.retrieveBindingsByElement(element);\n    let unbound = [];\n\n    bindings.forEach((binding) => {\n      if (gesture) {\n        if (typeof gesture === 'string' &&\n          this.state.registeredGestures[gesture]) {\n          let registeredGesture = this.state.registeredGestures[gesture];\n          if (registeredGesture.id === binding.gesture.id) {\n            element.removeEventListener(\n              binding.gesture.getId(),\n              binding.handler, binding.capture);\n            unbound.push(binding);\n          }\n        }\n      } else {\n        element.removeEventListener(\n          binding.gesture.getId(),\n          binding.handler,\n          binding.capture);\n        unbound.push(binding);\n      }\n    });\n\n    return unbound;\n  }\n\n  /* unbind*/\n\n  /**\n   * Registers a new gesture with an assigned key\n   * @param {String} key - The key used to register an element to that gesture\n   * @param {Gesture} gesture - A gesture object\n   */\n  register(key, gesture) {\n    if (typeof key !== 'string') {\n      throw new Error('Parameter key is an invalid string');\n    }\n\n    if (!gesture instanceof Gesture) {\n      throw new Error('Parameter gesture is an invalid Gesture object');\n    }\n\n    gesture.setType(key);\n    this.state.registerGesture(gesture, key);\n  }\n\n  /* register*/\n\n  /**\n   * Un-registers a gesture from the Region's state such that\n   * it is no longer emittable.\n   * Unbinds all events that were registered with the type.\n   * @param {String|Object} key - Gesture key that was used to\n   *  register the object\n   * @return {Object} - The Gesture object that was unregistered\n   *  or null if it could not be found.\n   */\n  unregister(key) {\n    this.state.bindings.forEach((binding) => {\n      if (binding.gesture.getType() === key) {\n        binding.element.removeEventListener(binding.gesture.getId(),\n          binding.handler, binding.capture);\n      }\n    });\n\n    let registeredGesture = this.state.registeredGestures[key];\n    delete this.state.registeredGestures[key];\n    return registeredGesture;\n  }\n}\n\nexport default Region;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Region.js","/**\n * @file Binder.js\n */\n\n/**\n * A chainable object that contains a single element to be bound upon.\n * Called from ZingTouch.bind(), and is used to chain over gesture callbacks.\n * @class\n */\nclass Binder {\n  /**\n   * Constructor function for the Binder class.\n   * @param {Element} element - The element to bind gestures to.\n   * @param {Boolean} bindOnce - Option to bind once and only emit\n   * the event once.\n   * @param {Object} state - The state of the Region that is being bound to.\n   * @return {Object} - Returns 'this' to be chained over and over again.\n   */\n  constructor(element, bindOnce, state) {\n    /**\n     * The element to bind gestures to.\n     * @type {Element}\n     */\n    this.element = element;\n\n    Object.keys(state.registeredGestures).forEach((key) => {\n      this[key] = (handler, capture) => {\n        state.addBinding(this.element, key, handler, capture, bindOnce);\n        return this;\n      };\n    });\n  }\n\n}\n\nexport default Binder;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Binder.js","/**\n * @file Gesture.js\n * Contains the Gesture class\n */\n\nimport util from './../core/util.js';\n\n/**\n * The Gesture class that all gestures inherit from.\n */\nclass Gesture {\n  /**\n   * Constructor function for the Gesture class.\n   * @class Gesture\n   */\n  constructor() {\n    /**\n     * The generic string type of gesture ('expand'|'pan'|'pinch'|\n     *  'rotate'|'swipe'|'tap').\n     * @type {String}\n     */\n    this.type = null;\n\n    /**\n     * The unique identifier for each gesture determined at bind time by the\n     * state object. This allows for distinctions across instance variables of\n     * Gestures that are created on the fly (e.g. Tap-1, Tap-2, etc).\n     * @type {String|null}\n     */\n    this.id = null;\n  }\n\n  /**\n   * Set the type of the gesture to be called during an event\n   * @param {String} type - The unique identifier of the gesture being created.\n   */\n  setType(type) {\n    this.type = type;\n  }\n\n  /**\n   * getType() - Returns the generic type of the gesture\n   * @return {String} - The type of gesture\n   */\n  getType() {\n    return this.type;\n  }\n\n  /**\n   * Set the id of the gesture to be called during an event\n   * @param {String} id - The unique identifier of the gesture being created.\n   */\n  setId(id) {\n    this.id = id;\n  }\n\n  /**\n   * Return the id of the event. If the id does not exist, return the type.\n   * @return {String}\n   */\n  getId() {\n    return (this.id !== null) ? this.id : this.type;\n  }\n\n  /**\n   * Updates internal properties with new ones, only if the properties exist.\n   * @param {Object} object\n   */\n  update(object) {\n    for (let key in object) {\n      if (this[key]) {\n        this[key] = object[key];\n      }\n    }\n  }\n\n  /**\n   * start() - Event hook for the start of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n\t * @param {Object} state - The state object of the current region.\n\t * @param {Element} element - The element associated to the binding.\n   * @return {null|Object}  - Default of null\n   */\n  start(inputs, state, element) {\n    return null;\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null|Object} - Default of null\n   */\n  move(inputs, state, element) {\n    return null;\n  }\n\n  /**\n   * end() - Event hook for the move of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null|Object}  - Default of null\n   */\n  end(inputs) {\n    return null;\n  }\n\n\t/**\n\t* isValid() - Pre-checks to ensure the invariants of a gesture are satisfied.\n\t* @param {Array} inputs - The array of Inputs on the screen\n\t* @param {Object} state - The state object of the current region.\n\t* @param {Element} element - The element associated to the binding.\n\t* @return {boolean} - If the gesture is valid\n\t*/\n\tisValid(inputs, state, element) {\n    let valid = true;\n    // Checks to see if all touches originated from within the target element.\n    if (inputs.length > 1) {\n      inputs.forEach((input) => {\n        if (!util.isInside(input.initial.x, input.initial.y, element)) {\n          valid = false;\n        }\n      });\n    }\n    return valid;\n    }\n\n}\n\nexport default Gesture;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Gesture.js","/**\n * @file util.js\n * Various accessor and mutator functions to handle state and validation.\n */\n\nconst CIRCLE_DEGREES = 360;\nconst HALF_CIRCLE_DEGREES = 180;\n\n/**\n *  Contains generic helper functions\n * @type {Object}\n * @namespace util\n */\nlet util = {\n\n  /**\n   * Normalizes window events to be either of type start, move, or end.\n   * @param {String} type - The event type emitted by the browser\n   * @return {null|String} - The normalized event, or null if it is an\n   * event not predetermined.\n   */\n  normalizeEvent(type) {\n    switch (type) {\n      case 'mousedown' :\n      case 'touchstart' :\n      case 'pointerdown' :\n        return 'start';\n      case 'mousemove' :\n      case 'touchmove' :\n      case 'pointermove' :\n        return 'move';\n      case 'mouseup' :\n      case 'touchend' :\n      case 'pointerup' :\n        return 'end';\n      default :\n        return null;\n    }\n  },\n  /* normalizeEvent*/\n\n  /**\n   * Determines if the current and previous coordinates are within or\n   * up to a certain tolerance.\n   * @param {Number} currentX - Current event's x coordinate\n   * @param {Number} currentY - Current event's y coordinate\n   * @param {Number} previousX - Previous event's x coordinate\n   * @param {Number} previousY - Previous event's y coordinate\n   * @param {Number} tolerance - The tolerance in pixel value.\n   * @return {boolean} - true if the current coordinates are\n   * within the tolerance, false otherwise\n   */\n  isWithin(currentX, currentY, previousX, previousY, tolerance) {\n    return ((Math.abs(currentY - previousY) <= tolerance) &&\n    (Math.abs(currentX - previousX) <= tolerance));\n  },\n  /* isWithin*/\n\n  /**\n   * Calculates the distance between two points.\n   * @param {Number} x0\n   * @param {Number} x1\n   * @param {Number} y0\n   * @param {Number} y1\n   * @return {number} The numerical value between two points\n   */\n  distanceBetweenTwoPoints(x0, x1, y0, y1) {\n    let dist = (Math.sqrt(((x1 - x0) * (x1 - x0)) + ((y1 - y0) * (y1 - y0))));\n    return Math.round(dist * 100) / 100;\n  },\n\n  /**\n   * Calculates the midpoint coordinates between two points.\n   * @param {Number} x0\n   * @param {Number} x1\n   * @param {Number} y0\n   * @param {Number} y1\n   * @return {Object} The coordinates of the midpoint.\n   */\n  getMidpoint(x0, x1, y0, y1) {\n    return {\n      x: ((x0 + x1) / 2),\n      y: ((y0 + y1) / 2),\n    };\n  },\n  /**\n   * Calculates the angle between the projection and an origin point.\n   *   |                (projectionX,projectionY)\n   *   |             /\n   *   |          /\n   *   |       /\n   *   |    / \n   *   | /__________\n   *    (originX, originY)\n   * @param {number} originX\n   * @param {number} originY\n   * @param {number} projectionX\n   * @param {number} projectionY\n   * @return {number} - Degree along the unit circle where the project lies\n   */\n  getAngle(originX, originY, projectionX, projectionY) {\n    let angle = Math.atan2(projectionY - originY, projectionX - originX) *\n      ((HALF_CIRCLE_DEGREES) / Math.PI);\n    return CIRCLE_DEGREES - ((angle < 0) ? (CIRCLE_DEGREES + angle) : angle);\n  },\n  /**\n   * Calculates the angular distance in degrees between two angles\n   *  along the unit circle\n   * @param {number} start - The starting point in degrees\n   * @param {number} end - The ending point in degrees\n   * @return {number} The number of degrees between the\n   * starting point and ending point. Negative degrees denote a clockwise\n   * direction, and positive a counter-clockwise direction.\n   */\n  getAngularDistance(start, end) {\n    let angle = (end - start) % CIRCLE_DEGREES;\n    let sign = (angle < 0) ? 1 : -1;\n    angle = Math.abs(angle);\n    return (angle > HALF_CIRCLE_DEGREES) ?\n    sign * (CIRCLE_DEGREES - angle) : sign * angle;\n  },\n\n  /**\n   * Calculates the velocity of pixel/milliseconds between two points\n   * @param {Number} startX\n   * @param {Number} startY\n   * @param {Number} startTime\n   * @param {Number} endX\n   * @param {Number} endY\n   * @param {Number} endTime\n   * @return {Number} velocity of px/time\n   */\n  getVelocity(startX, startY, startTime, endX, endY, endTime) {\n    let distance = this.distanceBetweenTwoPoints(startX, endX, startY, endY);\n    return (distance / (endTime - startTime));\n  },\n\n  /**\n   * Returns the farthest right input\n   * @param {Array} inputs\n   * @return {Object}\n   */\n  getRightMostInput(inputs) {\n    let rightMost = null;\n    let distance = Number.MIN_VALUE;\n    inputs.forEach((input) => {\n      if (input.initial.x > distance) {\n        rightMost = input;\n      }\n    });\n    return rightMost;\n  },\n\n  /**\n   * Determines is the value is an integer and not a floating point\n   * @param {Mixed} value\n   * @return {boolean}\n   */\n  isInteger(value) {\n    return (typeof value === 'number') && (value % 1 === 0);\n  },\n\n  /**\n   * Determines if the x,y position of the input is within then target.\n   * @param {Number} x -clientX\n   * @param {Number} y -clientY\n   * @param {Element} target\n   * @return {Boolean}\n   */\n  isInside(x, y, target) {\n    const rect = target.getBoundingClientRect();\n    return ((x > rect.left && x < rect.left + rect.width) &&\n    (y > rect.top && y < rect.top + rect.height));\n  },\n  /**\n   * Polyfill for event.propagationPath\n   * @param {Event} event\n   * @return {Array}\n   */\n  getPropagationPath(event) {\n    if (event.path) {\n      return event.path;\n    } else {\n      let path = [];\n      let node = event.target;\n      while (node != document) {\n        path.push(node);\n        node = node.parentNode;\n      }\n\n      return path;\n    }\n  },\n\n  /**\n   * Retrieve the index inside the path array\n   * @param {Array} path\n   * @param {Element} element\n   * @return {Element}\n   */\n  getPathIndex(path, element) {\n    let index = path.length;\n\n    path.forEach((obj, i) => {\n      if (obj === element) {\n        index = i;\n      }\n    });\n\n    return index;\n  },\n\n  setMSPreventDefault(element) {\n    element.style['-ms-content-zooming'] = 'none';\n    element.style['touch-action'] = 'none';\n  },\n\n  removeMSPreventDefault(element) {\n    element.style['-ms-content-zooming'] = '';\n    element.style['touch-action'] = '';\n  },\n};\nexport default util;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/util.js","/**\n * @file arbiter.js\n * Contains logic for the dispatcher\n */\n\nimport dispatcher from './dispatcher.js';\nimport interpreter from './interpreter.js';\nimport util from './util.js';\n\n/**\n * Function that handles event flow, negotiating with the interpreter,\n * and dispatcher.\n * 1. Receiving all touch events in the window.\n * 2. Determining which gestures are linked to the target element.\n * 3. Negotiating with the Interpreter what event should occur.\n * 4. Sending events to the dispatcher to emit events to the target.\n * @param {Event} event - The event emitted from the window object.\n * @param {Object} region - The region object of the current listener.\n */\nfunction arbiter(event, region) {\n  const state = region.state;\n\n  /*\n   Return if a gesture is not in progress and won't be. Also catches the case\n   where a previous event is in a partial state (2 finger pan, waits for both\n   inputs to reach touchend)\n   */\n  if (state.inputs.length === 0 && util.normalizeEvent(event.type) !==\n    'start') {\n    return;\n  }\n\n  /*\n   Check for 'stale' or events that lost focus\n   (e.g. a pan goes off screen/off region.)\n   Does not affect mobile devices.\n   */\n  if (typeof event.buttons !== 'undefined' &&\n    util.normalizeEvent(event.type) !== 'end' &&\n    event.buttons === 0) {\n    state.resetInputs();\n    return;\n  }\n\n  // Update the state with the new events. If the event is stopped, return;\n  if (!state.updateInputs(event, region.element)) {\n    return;\n  }\n\n  // Retrieve the initial target from any one of the inputs\n  const bindings = state.retrieveBindingsByInitialPos();\n  if (bindings.length > 0) {\n    if (region.preventDefault) {\n      util.setMSPreventDefault(region.element);\n      event.preventDefault ? event.preventDefault():(event.returnValue = false);\n    } else {\n      util.removeMSPreventDefault(region.element);\n    }\n\n    const toBeDispatched = {};\n    const gestures = interpreter(bindings, event, state);\n\n    /* Determine the deepest path index to emit the event\n     from, to avoid duplicate events being fired. */\n\n    gestures.forEach((gesture) => {\n      const id = gesture.binding.gesture.id;\n      if (toBeDispatched[id]) {\n        const path = util.getPropagationPath(event);\n        if (util.getPathIndex(path, gesture.binding.element) <\n          util.getPathIndex(path, toBeDispatched[id].binding.element)) {\n          toBeDispatched[id] = gesture;\n        }\n      } else {\n        toBeDispatched[id] = gesture;\n      }\n    });\n\n    Object.keys(toBeDispatched).forEach((index) => {\n      const gesture = toBeDispatched[index];\n      dispatcher(gesture.binding, gesture.data, gesture.events);\n    });\n  }\n\n  let endCount = 0;\n  state.inputs.forEach((input) => {\n    if (input.getCurrentEventType() === 'end') {\n      endCount++;\n    }\n  });\n\n  if (endCount === state.inputs.length) {\n    state.resetInputs();\n  }\n}\n\nexport default arbiter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/arbiter.js","/**\n * @file dispatcher.js\n * Contains logic for the dispatcher\n */\n\n/**\n * Emits data at the target element if available, and bubbles up from\n * the target to the parent until the document has been reached.\n * Called from the arbiter.\n * @param {Binding} binding - An object of type Binding\n * @param {Object} data - The metadata computed by the gesture being emitted.\n * @param {Array} events - An array of ZingEvents\n *  corresponding to the inputs on the screen.\n */\nfunction dispatcher(binding, data, events) {\n  data.events = events;\n\n  const newEvent = new CustomEvent(binding.gesture.getId(), {\n    detail: data,\n    bubbles: true,\n    cancelable: true,\n  });\n  emitEvent(binding.element, newEvent, binding);\n}\n\n/**\n * Emits the new event. Unbinds the event if the event was registered\n * at bindOnce.\n * @param {Element} target - Element object to emit the event to.\n * @param {Event} event - The CustomEvent to emit.\n * @param {Binding} binding - An object of type Binding\n */\nfunction emitEvent(target, event, binding) {\n  target.dispatchEvent(event);\n  if (binding.bindOnce) {\n    ZingTouch.unbind(binding.element, binding.gesture.getType());\n  }\n}\n\nexport default dispatcher;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/dispatcher.js","/**\n * @file interpreter.js\n * Contains logic for the interpreter\n */\n\nimport util from './util.js';\n\n/**\n * Receives an event and an array of Bindings (element -> gesture handler)\n * to determine what event will be emitted. Called from the arbiter.\n * @param {Array} bindings - An array containing Binding objects\n * that associate the element to an event handler.\n * @param {Object} event - The event emitted from the window.\n * @param {Object} state - The state object of the current listener.\n * @return {Object | null} - Returns an object containing a binding and\n * metadata, or null if a gesture will not be emitted.\n */\nfunction interpreter(bindings, event, state) {\n  const evType = util.normalizeEvent(event.type);\n  const candidates = [];\n  bindings.forEach((binding) => {\n    let result = binding.gesture[evType](state.inputs, state, binding.element);\n    if (result) {\n      const events = [];\n      state.inputs.forEach((input) => {\n        events.push(input.current);\n      });\n\n      candidates.push({\n        binding: binding,\n        data: result,\n        events: events,\n      });\n    }\n  });\n\n  return candidates;\n}\n\nexport default interpreter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/interpreter.js","/**\n * @file State.js\n */\n\nimport Gesture from './../../gestures/Gesture.js';\nimport Expand from './../../gestures/Expand.js';\nimport Pan from './../../gestures/Pan.js';\nimport Pinch from './../../gestures/Pinch.js';\nimport Rotate from './../../gestures/Rotate.js';\nimport Swipe from './../../gestures/Swipe.js';\nimport Tap from './../../gestures/Tap.js';\nimport Binding from './Binding.js';\nimport Input from './Input.js';\nimport util from './../util.js';\n\nconst DEFAULT_MOUSE_ID = 0;\n\n/**\n * Creates an object related to a Region's state,\n * and contains helper methods to update and clean up different states.\n */\nclass State {\n\n  /**\n   * Constructor for the State class.\n   * @param {String} regionId - The id the region this state is bound to.\n   */\n  constructor(regionId) {\n    /**\n     * The id for the region this state is bound to.\n     * @type {String}\n     */\n    this.regionId = regionId;\n\n    /**\n     * An array of current and recently inactive\n     *  Input objects related to a gesture.\n     * @type {Input}\n     */\n    this.inputs = [];\n\n    /**\n     * An array of Binding objects; The list of relations between elements,\n     *   their gestures, and the handlers.\n     * @type {Binding}\n     */\n    this.bindings = [];\n\n    /**\n     * The number of gestures that have been registered with this state\n     * @type {Number}\n     */\n    this.numGestures = 0;\n\n    /**\n     * A key/value map all the registered gestures for the listener.\n     *  Note: Can only have one gesture registered to one key.\n     * @type {Object}\n     */\n    this.registeredGestures = {};\n\n    this.registerGesture(new Expand(), 'expand');\n    this.registerGesture(new Pan(), 'pan');\n    this.registerGesture(new Rotate(), 'rotate');\n    this.registerGesture(new Pinch(), 'pinch');\n    this.registerGesture(new Swipe(), 'swipe');\n    this.registerGesture(new Tap(), 'tap');\n  }\n\n  /**\n   * Creates a new binding with the given element and gesture object.\n   * If the gesture object provided is unregistered, it's reference\n   * will be saved in as a binding to be later referenced.\n   * @param  {Element} element - The element the gesture is bound to.\n   * @param {String|Object} gesture  - Either a name of a registered gesture,\n   *  or an unregistered  Gesture object.\n   * @param {Function} handler - The function handler to be called\n   *  when the event is emitted. Used to bind/unbind.\n   * @param {Boolean} capture - Whether the gesture is to be\n   *  detected in the capture of bubble phase. Used to bind/unbind.\n   * @param {Boolean} bindOnce - Option to bind once and\n   *  only emit the event once.\n   */\n  addBinding(element, gesture, handler, capture, bindOnce) {\n    let boundGesture;\n\n    // Error type checking.\n    if (element && typeof element.tagName === 'undefined') {\n      throw new Error('Parameter element is an invalid object.');\n    }\n\n    if (typeof handler !== 'function') {\n      throw new Error('Parameter handler is invalid.');\n    }\n\n    if (typeof gesture === 'string' &&\n      Object.keys(this.registeredGestures).indexOf(gesture) === -1) {\n      throw new Error('Parameter ' + gesture + ' is not a registered gesture');\n    } else if (typeof gesture === 'object' && !(gesture instanceof Gesture)) {\n      throw new Error('Parameter for the gesture is not of a Gesture type');\n    }\n\n    if (typeof gesture === 'string') {\n      boundGesture = this.registeredGestures[gesture];\n    } else {\n      boundGesture = gesture;\n      if (boundGesture.id === '') {\n        this.assignGestureId(boundGesture);\n      }\n    }\n\n    this.bindings.push(new Binding(element, boundGesture,\n      handler, capture, bindOnce));\n    element.addEventListener(boundGesture.getId(), handler, capture);\n  }\n\n  /**\n   * Retrieves the Binding by which an element is associated to.\n   * @param {Element} element - The element to find bindings to.\n   * @return {Array} - An array of Bindings to which that element is bound\n   */\n  retrieveBindingsByElement(element) {\n    let matches = [];\n    this.bindings.map((binding) => {\n      if (binding.element === element) {\n        matches.push(binding);\n      }\n    });\n    return matches;\n  }\n\n  /**\n   * Retrieves all bindings based upon the initial X/Y position of the inputs.\n   * e.g. if gesture started on the correct target element,\n   *  but diverted away into the correct region, this would still be valid.\n   * @return {Array} - An array of Bindings to which that element is bound\n   */\n  retrieveBindingsByInitialPos() {\n    let matches = [];\n    this.bindings.forEach((binding) => {\n      // Determine if at least one input is in the target element.\n      // They should all be in the region based upon a prior check\n      let inputsInside = this.inputs.filter((input) => {\n        return util.isInside(input.initial.x, input.initial.y, binding.element);\n      });\n      if (inputsInside.length > 0) {\n        matches.push(binding);\n      }\n    });\n    return matches;\n  }\n\n  /**\n   * Updates the inputs with new information based upon a new event being fired.\n   * @param {Event} event - The event being captured.\n   * @param {Element} regionElement - The element where\n   *  this current Region is bound to.\n   * @return {boolean} - returns true for a successful update,\n   *  false if the event is invalid.\n   */\n  updateInputs(event, regionElement) {\n    let identifier = DEFAULT_MOUSE_ID;\n    let eventType = (event.touches) ?\n      'TouchEvent' : (event.pointerType) ? 'PointerEvent' : 'MouseEvent';\n    switch (eventType) {\n      case 'TouchEvent':\n\n        for (let index in event.changedTouches) {\n          if (event.changedTouches.hasOwnProperty(index) &&\n            util.isInteger((parseInt(index)))) {\n            identifier = event.changedTouches[index].identifier;\n            update(event, this, identifier, regionElement);\n          }\n        }\n        break;\n\n      case 'PointerEvent':\n        identifier = event.pointerId;\n        update(event, this, identifier, regionElement);\n        break;\n\n      case 'MouseEvent':\n      default:\n        update(event, this, DEFAULT_MOUSE_ID, regionElement);\n        break;\n    }\n    return true;\n\n    function update(event, state, identifier, regionElement) {\n      let eventType = util.normalizeEvent(event.type);\n      let input = findInputById(state.inputs, identifier);\n\n      // A starting input was not cleaned up properly and still exists.\n      if (eventType === 'start' && input) {\n        state.resetInputs();\n        return;\n      }\n\n      // An input has moved outside the region.\n      if (eventType !== 'start' &&\n        input &&\n        !util.isInside(input.current.x, input.current.y, regionElement)) {\n         state.resetInputs();\n        return;\n      }\n\n      if (eventType !== 'start' && !input) {\n        state.resetInputs();\n        return;\n      }\n\n      if (eventType === 'start') {\n        state.inputs.push(new Input(event, identifier));\n      } else {\n        input.update(event, identifier);\n      }\n    }\n  }\n\n  /**\n   * Removes all inputs from the state, allowing for a new gesture.\n   */\n  resetInputs() {\n    this.inputs = [];\n  }\n\n  /**\n   * Counts the number of active inputs at any given time.\n   * @return {Number} - The number of active inputs.\n   */\n  numActiveInputs() {\n    let endType = this.inputs.filter((input) => {\n      return input.current.type !== 'end';\n    });\n    return endType.length;\n  }\n\n  /**\n   * Register the gesture to the current region.\n   * @param {Object} gesture - The gesture to register\n   * @param {String} key - The key to define the new gesture as.\n   */\n  registerGesture(gesture, key) {\n    this.assignGestureId(gesture);\n    this.registeredGestures[key] = gesture;\n  }\n\n  /**\n   * Tracks the gesture to this state object to become uniquely identifiable.\n   * Useful for nested Regions.\n   * @param {Gesture} gesture - The gesture to track\n   */\n  assignGestureId(gesture) {\n    gesture.setId(this.regionId + '-' + this.numGestures++);\n  }\n\n}\n/**\n * Searches through each input, comparing the browser's identifier key\n *  for touches, to the stored one in each input\n * @param {Array} inputs - The array of inputs in state.\n * @param {String} identifier - The identifier the browser has assigned.\n * @return {Input} - The input object with the corresponding identifier,\n *  null if it did not find any.\n */\nfunction findInputById(inputs, identifier) {\n  for (let i = 0; i < inputs.length; i++) {\n    if (inputs[i].identifier === identifier) {\n      return inputs[i];\n    }\n  }\n\n  return null;\n}\n\nexport default State;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/State.js","/**\n * @file Expand.js\n * Contains the Expand class\n */\n\nimport Distance from './Distance.js';\n\n/**\n * An Expand is defined as two inputs moving farther away from each other.\n * This gesture does not account for any start/end events to allow for the\n * event to interact with the Pan and Pinch events.\n * @class Expand\n */\nclass Expand extends Distance {\n\n  /**\n   * Constructor function for the Expand class.\n   * @param {object} options\n   */\n  constructor(options) {\n    super(options);\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'expand';\n  }\n\n}\n\nexport default Expand;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Expand.js","/**\n * @file Distance.js\n * Contains the abstract Distance class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 2;\nconst DEFAULT_MIN_THRESHOLD = 1;\n\n/**\n * A Distance is defined as two inputs moving either together or apart.\n * @class Distance\n */\nclass Distance extends Gesture {\n  /**\n   * Constructor function for the Distance class.\n   * @param {Object} options\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'distance';\n\n    /**\n     * The minimum amount in pixels the inputs must move until it is fired.\n     * @type {Number}\n     */\n    this.threshold = (options && options.threshold) ?\n      options.threshold : DEFAULT_MIN_THRESHOLD;\n  }\n\n  /**\n   * Event hook for the start of a gesture. Initialized the lastEmitted\n   * gesture and stores it in the first input for reference events.\n   * @param {Array} inputs\n   */\n  start(inputs, state, element) {\n  if(!this.isValid(inputs, state, element)) {\n    return null;\n  }\n    if (inputs.length === DEFAULT_INPUTS) {\n      // Store the progress in the first input.\n      let progress = inputs[0].getGestureProgress(this.type);\n      progress.lastEmittedDistance = util.distanceBetweenTwoPoints(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n    }\n  }\n\n  /**\n   * Event hook for the move of a gesture.\n   *  Determines if the two points are moved in the expected direction relative\n   *  to the current distance and the last distance.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {Object | null} - Returns the distance in pixels between two inputs\n   */\n  move(inputs, state, element) {\n    if (state.numActiveInputs() === DEFAULT_INPUTS) {\n      let currentDistance = util.distanceBetweenTwoPoints(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n      let lastDistance = util.distanceBetweenTwoPoints(\n        inputs[0].previous.x,\n        inputs[1].previous.x,\n        inputs[0].previous.y,\n        inputs[1].previous.y);\n\n      const centerPoint = util.getMidpoint(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n\n      // Retrieve the first input's progress.\n      let progress = inputs[0].getGestureProgress(this.type);\n\n      if (this.type === 'expand') {\n        if (currentDistance < lastDistance) {\n          progress.lastEmittedDistance = currentDistance;\n        } else if ((currentDistance - progress.lastEmittedDistance >=\n          this.threshold)) {\n          progress.lastEmittedDistance = currentDistance;\n          return {\n            distance: currentDistance,\n            center: centerPoint,\n          };\n        }\n      } else {\n        if (currentDistance > lastDistance) {\n          progress.lastEmittedDistance = currentDistance;\n        } else if (currentDistance < lastDistance &&\n          (progress.lastEmittedDistance - currentDistance >= this.threshold)) {\n          progress.lastEmittedDistance = currentDistance;\n          return {\n            distance: currentDistance,\n            center: centerPoint,\n          };\n        }\n      }\n\n      return null;\n    }\n  }\n}\n\nexport default Distance;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Distance.js","/**\n * @file Pan.js\n * Contains the Pan class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MIN_THRESHOLD = 1;\n\n/**\n * A Pan is defined as a normal movement in any direction on a screen.\n * Pan gestures do not track start events and can interact with pinch and \\\n *  expand gestures.\n * @class Pan\n */\nclass Pan extends Gesture {\n  /**\n   * Constructor function for the Pan class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.numInputs=1] - Number of inputs for the\n   *  Pan gesture.\n   * @param {Number} [options.threshold=1] - The minimum number of\n   * pixels the input has to move to trigger this gesture.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'pan';\n\n    /**\n     * The number of inputs to trigger a Pan can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * The minimum amount in pixels the pan must move until it is fired.\n     * @type {Number}\n     */\n    this.threshold = (options && options.threshold) ?\n      options.threshold : DEFAULT_MIN_THRESHOLD;\n  }\n\n  /**\n   * Event hook for the start of a gesture. Marks each input as active,\n   * so it can invalidate any end events.\n   * @param {Array} inputs\n   */\n  start(inputs) {\n    inputs.forEach((input) => {\n      let progress = input.getGestureProgress(this.getId());\n      progress.active = true;\n      progress.lastEmitted = {\n        x: input.current.x,\n        y: input.current.y,\n      };\n    });\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture.\n   * Fired whenever the input length is met, and keeps a boolean flag that\n   * the gesture has fired at least once.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {Object} - Returns the distance in pixels between the two inputs.\n   */\n  move(inputs, state, element) {\n    if (this.numInputs === inputs.length) {\n      var output = {\n        data: [],\n      };\n      for (let i = 0; i < inputs.length; i++) {\n        let progress = inputs[i].getGestureProgress(this.getId());\n\n        let reachedThreshold = false;\n\n        // Check threshold distance\n        const yThreshold = Math.abs(inputs[i].current.y -\n            progress.lastEmitted.y) > this.threshold;\n        const xThreshold = Math.abs(inputs[i].current.x -\n            progress.lastEmitted.x) > this.threshold;\n        reachedThreshold = yThreshold || xThreshold;\n\n        if (progress.active && reachedThreshold) {\n          output.data[i] = {\n            distanceFromOrigin: util.distanceBetweenTwoPoints(\n              inputs[i].initial.x,\n              inputs[i].current.x,\n              inputs[i].initial.y,\n              inputs[i].current.y),\n            directionFromOrigin: util.getAngle(\n              inputs[i].initial.x,\n              inputs[i].initial.y,\n              inputs[i].current.x,\n              inputs[i].current.y),\n            currentDirection: util.getAngle(\n              progress.lastEmitted.x,\n              progress.lastEmitted.y,\n              inputs[i].current.x,\n              inputs[i].current.y),\n          };\n          progress.lastEmitted.x = inputs[i].current.x;\n          progress.lastEmitted.y = inputs[i].current.y;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    return output;\n  }\n\n  /* move*/\n\n  /**\n   * end() - Event hook for the end of a gesture. If the gesture has at least\n   * fired once, then it ends on the first end event such that any remaining\n   * inputs will not trigger the event until all inputs have reached the\n   * touchend event. Any touchend->touchstart events that occur before all\n   * inputs are fully off the screen should not fire.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null} - null if the gesture is not to be emitted,\n   *  Object with information otherwise.\n   */\n  end(inputs) {\n    inputs.forEach((input) => {\n      let progress = input.getGestureProgress(this.getId());\n      progress.active = false;\n    });\n    return null;\n  }\n\n  /* end*/\n}\n\nexport default Pan;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Pan.js","/**\n * @file Pinch.js\n * Contains the Pinch class\n */\n\nimport Distance from './Distance.js';\nimport util from './../core/util.js';\n\n/**\n * An Pinch is defined as two inputs moving closer to each other.\n * This gesture does not account for any start/end events to allow for the event\n * to interact with the Pan and Pinch events.\n * @class Pinch\n */\nclass Pinch extends Distance {\n  /**\n   * Constructor function for the Pinch class.\n   * @param {Object} options\n   */\n  constructor(options) {\n    super(options);\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'pinch';\n  }\n\n}\n\nexport default Pinch;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Pinch.js","/**\n * @file Rotate.js\n * Contains the Rotate class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst MAX_INPUTS = 2;\n\n/**\n * A Rotate is defined as two inputs moving about a circle,\n * maintaining a relatively equal radius.\n * @class Rotate\n */\nclass Rotate extends Gesture {\n  /**\n   * Constructor function for the Rotate class.\n   */\n  constructor() {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'rotate';\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture. Obtains the midpoint of two\n   * the two inputs and calculates the projection of the right most input along\n   * a unit circle to obtain an angle. This angle is compared to the previously\n   * calculated angle to output the change of distance, and is compared to the\n   * initial angle to output the distance from the initial angle to the current\n   * angle.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current listener.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - null if this event did not occur\n   * @return {Object} obj.angle - The current angle along the unit circle\n   * @return {Object} obj.distanceFromOrigin - The angular distance travelled\n   * from the initial right most point.\n   * @return {Object} obj.distanceFromLast - The change of angle between the\n   * last position and the current position.\n   */\n  move(inputs, state, element) {\n    if (state.numActiveInputs() <= MAX_INPUTS) {\n      let referencePivot;\n      let diffX;\n      let diffY;\n      let input;\n      if (state.numActiveInputs() === 1) {\n        let bRect = element.getBoundingClientRect();\n        referencePivot = {\n          x: bRect.left + bRect.width / 2,\n          y: bRect.top + bRect.height / 2,\n        };\n        input = inputs[0];\n        diffX = diffY = 0;\n      } else {\n        referencePivot = util.getMidpoint(\n          inputs[0].initial.x,\n          inputs[1].initial.x,\n          inputs[0].initial.y,\n          inputs[1].initial.y);\n        let currentPivot = util.getMidpoint(\n          inputs[0].current.x,\n          inputs[1].current.x,\n          inputs[0].current.y,\n          inputs[1].current.y);\n        diffX = referencePivot.x - currentPivot.x;\n        diffY = referencePivot.y - currentPivot.y;\n        input = util.getRightMostInput(inputs);\n      }\n\n      // Translate the current pivot point.\n      let currentAngle = util.getAngle(referencePivot.x, referencePivot.y,\n        input.current.x + diffX, input.current.y + diffY);\n\n      let progress = input.getGestureProgress(this.getId());\n      if (!progress.initialAngle) {\n        progress.initialAngle = progress.previousAngle = currentAngle;\n        progress.distance = progress.change = 0;\n      } else {\n        progress.change = util.getAngularDistance(\n          progress.previousAngle,\n          currentAngle);\n        progress.distance = progress.distance + progress.change;\n      }\n\n      progress.previousAngle = currentAngle;\n\n      return {\n        angle: currentAngle,\n        distanceFromOrigin: progress.distance,\n        distanceFromLast: progress.change,\n      };\n    }\n\n    return null;\n  }\n\n  /* move*/\n}\n\nexport default Rotate;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Rotate.js","/**\n * @file Swipe.js\n * Contains the Swipe class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MAX_REST_TIME = 100;\nconst DEFAULT_ESCAPE_VELOCITY = 0.2;\nconst DEFAULT_TIME_DISTORTION = 100;\nconst DEFAULT_MAX_PROGRESS_STACK = 10;\n\n/**\n * A swipe is defined as input(s) moving in the same direction in an relatively\n * increasing velocity and leaving the screen at some point before it drops\n * below it's escape velocity.\n * @class Swipe\n */\nclass Swipe extends Gesture {\n\n  /**\n   * Constructor function for the Swipe class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.numInputs] - The number of inputs to trigger a\n   * Swipe can be variable, and the maximum number being a factor of the browser\n   *  move and current move events.\n   * @param {Number} [options.maxRestTime] - The maximum resting time a point\n   *  has between it's last\n   * @param {Number} [options.escapeVelocity] - The minimum velocity the input\n   *  has to be at to emit a swipe.\n   * @param {Number} [options.timeDistortion] - (EXPERIMENTAL) A value of time\n   *  in milliseconds to distort between events.\n   * @param {Number} [options.maxProgressStack] - (EXPERIMENTAL)The maximum\n   *  amount of move events to keep\n   * track of for a swipe.\n   */\n  constructor(options) {\n    super();\n    /**\n     * The type of the Gesture\n     * @type {String}\n     */\n    this.type = 'swipe';\n\n    /**\n     * The number of inputs to trigger a Swipe can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * The maximum resting time a point has between it's last move and\n     * current move events.\n     * @type {Number}\n     */\n    this.maxRestTime = (options && options.maxRestTime) ?\n      options.maxRestTime : DEFAULT_MAX_REST_TIME;\n\n    /**\n     * The minimum velocity the input has to be at to emit a swipe.\n     * This is useful for determining the difference between\n     * a swipe and a pan gesture.\n     * @type {number}\n     */\n    this.escapeVelocity = (options && options.escapeVelocity) ?\n      options.escapeVelocity : DEFAULT_ESCAPE_VELOCITY;\n\n    /**\n     * (EXPERIMENTAL) A value of time in milliseconds to distort between events.\n     * Browsers do not accurately measure time with the Date constructor in\n     * milliseconds, so consecutive events sometimes display the same timestamp\n     * but different x/y coordinates. This will distort a previous time\n     * in such cases by the timeDistortion's value.\n     * @type {number}\n     */\n    this.timeDistortion = (options && options.timeDistortion) ?\n      options.timeDistortion : DEFAULT_TIME_DISTORTION;\n\n    /**\n     * (EXPERIMENTAL) The maximum amount of move events to keep track of for a\n     * swipe. This helps give a more accurate estimate of the user's velocity.\n     * @type {number}\n     */\n    this.maxProgressStack = (options && options.maxProgressStack) ?\n      options.maxProgressStack : DEFAULT_MAX_PROGRESS_STACK;\n  }\n\n  /**\n   * Event hook for the move of a gesture. Captures an input's x/y coordinates\n   * and the time of it's event on a stack.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - Swipe does not emit from a move.\n   */\n  move(inputs, state, element) {\n    if (this.numInputs === inputs.length) {\n      for (let i = 0; i < inputs.length; i++) {\n        let progress = inputs[i].getGestureProgress(this.getId());\n        if (!progress.moves) {\n          progress.moves = [];\n        }\n\n        progress.moves.push({\n          time: new Date().getTime(),\n          x: inputs[i].current.x,\n          y: inputs[i].current.y,\n        });\n\n        if (progress.length > this.maxProgressStack) {\n          progress.moves.shift();\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /* move*/\n\n  /**\n   * Determines if the input's history validates a swipe motion.\n   * Determines if it did not come to a complete stop (maxRestTime), and if it\n   * had enough of a velocity to be considered (ESCAPE_VELOCITY).\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null|Object} - null if the gesture is not to be emitted,\n   *  Object with information otherwise.\n   */\n  end(inputs) {\n    if (this.numInputs === inputs.length) {\n      let output = {\n        data: [],\n      };\n\n      for (var i = 0; i < inputs.length; i++) {\n        // Determine if all input events are on the 'end' event.\n        if (inputs[i].current.type !== 'end') {\n          return;\n        }\n\n        let progress = inputs[i].getGestureProgress(this.getId());\n        if (progress.moves && progress.moves.length > 2) {\n          // CHECK : Return if the input has not moved in maxRestTime ms.\n\n          let currentMove = progress.moves.pop();\n          if ((new Date().getTime()) - currentMove.time > this.maxRestTime) {\n            return null;\n          }\n\n          let lastMove;\n          let index = progress.moves.length - 1;\n\n          /* Date is unreliable, so we retrieve the last move event where\n           the time is not the same. */\n          while (index !== -1) {\n            if (progress.moves[index].time !== currentMove.time) {\n              lastMove = progress.moves[index];\n              break;\n            }\n\n            index--;\n          }\n\n          /* If the date is REALLY unreliable, we apply a time distortion\n           to the last event.\n           */\n          if (!lastMove) {\n            lastMove = progress.moves.pop();\n            lastMove.time += this.timeDistortion;\n          }\n\n          var velocity = util.getVelocity(lastMove.x, lastMove.y, lastMove.time,\n            currentMove.x, currentMove.y, currentMove.time);\n\n          output.data[i] = {\n            velocity: velocity,\n            currentDirection: util.getAngle(\n              lastMove.x,\n              lastMove.y,\n              currentMove.x,\n              currentMove.y),\n          };\n        }\n      }\n\n      for (var i = 0; i < output.data.length; i++) {\n        if (velocity < this.escapeVelocity) {\n          return null;\n        }\n      }\n\n      if (output.data.length > 0) {\n        return output;\n      }\n    }\n\n    return null;\n  }\n\n  /* end*/\n}\n\nexport default Swipe;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Swipe.js","/**\n * @file Tap.js\n * Contains the Tap class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_MIN_DELAY_MS = 0;\nconst DEFAULT_MAX_DELAY_MS = 300;\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MOVE_PX_TOLERANCE = 10;\n\n/**\n * A Tap is defined as a touchstart to touchend event in quick succession.\n * @class Tap\n */\nclass Tap extends Gesture {\n  /**\n   * Constructor function for the Tap class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.minDelay=0] - The minimum delay between a\n   * touchstart and touchend can be configured in milliseconds.\n   * @param {Number} [options.maxDelay=300] - The maximum delay between a\n   * touchstart and touchend can be configured in milliseconds.\n   * @param {Number} [options.numInputs=1] - Number of inputs for Tap gesture.\n   * @param {Number} [options.tolerance=10] - The tolerance in pixels\n   *  a user can move.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'tap';\n\n    /**\n     * The minimum amount between a touchstart and a touchend can be configured\n     * in milliseconds. The minimum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     * @type {Number}\n     */\n    this.minDelay = (options && options.minDelay) ?\n      options.minDelay : DEFAULT_MIN_DELAY_MS;\n\n    /**\n     * The maximum delay between a touchstart and touchend can be configured in\n     * milliseconds. The maximum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     * @type {Number}\n     */\n    this.maxDelay = (options && options.maxDelay) ?\n      options.maxDelay : DEFAULT_MAX_DELAY_MS;\n\n    /**\n     * The number of inputs to trigger a Tap can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * A move tolerance in pixels allows some slop between a user's start to end\n     * events. This allows the Tap gesture to be triggered more easily.\n     * @type {number}\n     */\n    this.tolerance = (options && options.tolerance) ?\n      options.tolerance : DEFAULT_MOVE_PX_TOLERANCE;\n  }\n\n  /* constructor*/\n\n  /**\n   * Event hook for the start of a gesture. Keeps track of when the inputs\n   * trigger the start event.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @return {null} - Tap does not trigger on a start event.\n   */\n  start(inputs) {\n    if (inputs.length === this.numInputs) {\n      inputs.forEach((input) => {\n        let progress = input.getGestureProgress(this.type);\n        progress.start = new Date().getTime();\n      });\n    }\n\n    return null;\n  }\n\n  /* start*/\n\n  /**\n   * Event hook for the move of a gesture. The Tap event reaches here if the\n   * user starts to move their input before an 'end' event is reached.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - Tap does not trigger on a move event.\n   */\n  move(inputs, state, element) {\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getCurrentEventType() === 'move') {\n        let current = inputs[i].current;\n        let previous = inputs[i].previous;\n        if (!util.isWithin(\n            current.x,\n            current.y,\n            previous.x,\n            previous.y,\n            this.tolerance)) {\n          let type = this.type;\n          inputs.forEach(function(input) {\n            input.resetProgress(type);\n          });\n\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /* move*/\n\n  /**\n   * Event hook for the end of a gesture.\n   * Determines if this the tap event can be fired if the delay and tolerance\n   * constraints are met. Also waits for all of the inputs to be off the screen\n   * before determining if the gesture is triggered.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @return {null|Object} - null if the gesture is not to be emitted,\n   * Object with information otherwise. Returns the interval time between start\n   * and end events.\n   */\n  end(inputs) {\n    if (inputs.length !== this.numInputs) {\n      return null;\n    }\n\n    let startTime = Number.MAX_VALUE;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getCurrentEventType() !== 'end') {\n        return null;\n      }\n\n      let progress = inputs[i].getGestureProgress(this.type);\n      if (!progress.start) {\n        return null;\n      }\n\n      // Find the most recent input's startTime\n      if (progress.start < startTime) {\n        startTime = progress.start;\n      }\n    }\n\n    let interval = new Date().getTime() - startTime;\n    if ((this.minDelay <= interval) && (this.maxDelay >= interval)) {\n      return {\n        interval: interval,\n      };\n    } else {\n      let type = this.type;\n      inputs.forEach(function(input) {\n        input.resetProgress(type);\n      });\n\n      return null;\n    }\n  }\n\n  /* end*/\n}\n\nexport default Tap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/gestures/Tap.js","/**\n * @file Binding.js\n */\n\n/**\n * Responsible for creating a binding between an element and a gesture.\n * @class Binding\n */\nclass Binding {\n  /**\n   * Constructor function for the Binding class.\n   * @param {Element} element - The element to associate the gesture to.\n   * @param {Gesture} gesture - A instance of the Gesture type.\n   * @param {Function} handler - The function handler to execute when a\n   * gesture is recognized\n   * on the associated element.\n   * @param {Boolean} [capture=false] - A boolean signifying if the event is\n   * to be emitted during\n   * the capture or bubble phase.\n   * @param {Boolean} [bindOnce=false] - A boolean flag\n   * used for the bindOnce syntax.\n   */\n  constructor(element, gesture, handler, capture, bindOnce) {\n    /**\n     * The element to associate the gesture to.\n     * @type {Element}\n     */\n    this.element = element;\n    /**\n     * A instance of the Gesture type.\n     * @type {Gesture}\n     */\n    this.gesture = gesture;\n    /**\n     * The function handler to execute when a gesture is\n     * recognized on the associated element.\n     * @type {Function}\n     */\n    this.handler = handler;\n\n    /**\n     * A boolean signifying if the event is to be\n     * emitted during the capture or bubble phase.\n     * @type {Boolean}\n     */\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\n\n    /**\n     * A boolean flag used for the bindOnce syntax.\n     * @type {Boolean}\n     */\n    this.bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\n  }\n\n}\n\nexport default Binding;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Binding.js","/**\n * @file Input.js\n */\n\nimport ZingEvent from './ZingEvent.js';\n\n/**\n * Tracks a single input and contains information about the\n * current, previous, and initial events.\n * Contains the progress of each Input and it's associated gestures.\n * @class Input\n */\nclass Input {\n\n  /**\n   * Constructor function for the Input class.\n   * @param {Event} event - The Event object from the window\n   * @param {Number} [identifier=0] - The identifier for each input event\n   * (taken from event.changedTouches)\n   */\n  constructor(event, identifier) {\n    let currentEvent = new ZingEvent(event, identifier);\n\n    /**\n     * Holds the initial event object. A touchstart/mousedown event.\n     * @type {ZingEvent}\n     */\n    this.initial = currentEvent;\n\n    /**\n     * Holds the most current event for this Input, disregarding any other past,\n     * current, and future events that other Inputs participate in.\n     * e.g. This event ended in an 'end' event, but another Input is still\n     * participating in events -- this will not be updated in such cases.\n     * @type {ZingEvent}\n     */\n    this.current = currentEvent;\n\n    /**\n     * Holds the previous event that took place.\n     * @type {ZingEvent}\n     */\n    this.previous = currentEvent;\n\n    /**\n     * Refers to the event.touches index, or 0 if a simple mouse event occurred.\n     * @type {Number}\n     */\n    this.identifier = (typeof identifier !== 'undefined') ? identifier : 0;\n\n    /**\n     * Stores internal state between events for\n     * each gesture based off of the gesture's id.\n     * @type {Object}\n     */\n    this.progress = {};\n  }\n\n  /**\n   * Receives an input, updates the internal state of what the input has done.\n   * @param {Event} event - The event object to wrap with a ZingEvent.\n   * @param {Number} touchIdentifier - The index of inputs, from event.touches\n   */\n  update(event, touchIdentifier) {\n    this.previous = this.current;\n    this.current = new ZingEvent(event, touchIdentifier);\n  }\n\n  /**\n   * Returns the progress of the specified gesture.\n   * @param {String} id - The identifier for each unique Gesture's progress.\n   * @return {Object} - The progress of the gesture.\n   * Creates an empty object if no progress has begun.\n   */\n  getGestureProgress(id) {\n    if (!this.progress[id]) {\n      this.progress[id] = {};\n    }\n    return this.progress[id];\n  }\n\n  /**\n   * Returns the normalized current Event's type.\n   * @return {String} The current event's type ( start | move | end )\n   */\n  getCurrentEventType() {\n    return this.current.type;\n  }\n\n  /**\n   * Resets a progress/state object of the specified gesture.\n   * @param {String} id - The identifier of the specified gesture\n   */\n  resetProgress(id) {\n    this.progress[id] = {};\n  }\n\n}\n\nexport default Input;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/Input.js","/**\n * @file ZingEvent.js\n * Contains logic for ZingEvents\n */\n\nimport util from '../util.js';\n\nconst INITIAL_COORDINATE = 0;\n/**\n * An event wrapper that normalizes events across browsers and input devices\n * @class ZingEvent\n */\nclass ZingEvent {\n  /**\n   * @constructor\n   * @param {Event} event - The event object being wrapped.\n   * @param {Array} event.touches - The number of touches on\n   *  a screen (mobile only).\n   * @param {Object} event.changedTouches - The TouchList representing\n   * points that participated in the event.\n   * @param {Number} touchIdentifier - The index of touch if applicable\n   */\n  constructor(event, touchIdentifier) {\n    /**\n     * The original event object.\n     * @type {Event}\n     */\n    this.originalEvent = event;\n\n    /**\n     * The type of event or null if it is an event not predetermined.\n     * @see util.normalizeEvent\n     * @type {String | null}\n     */\n    this.type = util.normalizeEvent(event.type);\n\n    /**\n     * The X coordinate for the event, based off of the client.\n     * @type {number}\n     */\n    this.x = INITIAL_COORDINATE;\n\n    /**\n     * The Y coordinate for the event, based off of the client.\n     * @type {number}\n     */\n    this.y = INITIAL_COORDINATE;\n\n    let eventObj;\n    if (event.touches && event.changedTouches) {\n      for (let i = 0; i < event.changedTouches.length; i++) {\n        if (event.changedTouches[i].identifier === touchIdentifier) {\n          eventObj = event.changedTouches[i];\n          break;\n        }\n      }\n    } else {\n      eventObj = event;\n    }\n\n    this.x = this.clientX = eventObj.clientX;\n    this.y = this.clientY = eventObj.clientY;\n\n    this.pageX = eventObj.pageX;\n    this.pageY = eventObj.pageY;\n\n    this.screenX = eventObj.screenX;\n    this.screenY = eventObj.screenY;\n  }\n}\n\nexport default ZingEvent;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/classes/ZingEvent.js"],"sourceRoot":""}